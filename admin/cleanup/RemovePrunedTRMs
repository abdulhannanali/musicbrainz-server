#!/usr/bin/perl -w
# vi: set ts=4 sw=4 :
#____________________________________________________________________________
#
#   MusicBrainz -- The community music metadata project.
#
#   Copyright (C) 1998 Robert Kaye
#   Copyright (C) 2001 Luke Harless
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#   $Id$
#____________________________________________________________________________

use strict;

use FindBin;
use lib "$FindBin::Bin/../../lib";

use Getopt::Long qw( GetOptions );
my $chunk = 1000;
my $commit = 0;
my $full = 0;
my ($la_lwm, $la_hwm) = (1, 2);
my $sleep;
GetOptions(
	"chunk=i"	=> \$chunk,
	"commit=i"	=> \$commit,
	"full"		=> \$full,
	"la-hwm=f"	=> \$la_hwm,
	"la-lwm=f"	=> \$la_lwm,
	"sleep=i"	=> \$sleep,
) or exit 2;

use DBDefs;
use MusicBrainz;

print localtime() . " : RemovePrunedTRMs starting\n";
eval 'END { print localtime() . " : RemovePrunedTRMs complete\n"; }';

my $mb = MusicBrainz->new;
$mb->Login;
my $sql = Sql->new($mb->{DBH});

nibble(
	"trmjoins_to_throw", "id",
	[qw( trmjoin_stat trmjoin )],
	"DELETE FROM trmjoin_stat WHERE trmjoin_id IN (%s)",
	"DELETE FROM trmjoin WHERE id IN (%s)",
);

nibble(
	"trms_to_throw", "id",
	[qw( trm_stat trm )],
	"DELETE FROM trm_stat WHERE trm_id IN (%s)",
	"DELETE FROM trm WHERE id IN (%s)",
);

sub nibble
{
	my ($table, $idcol, $tables, @queries) = @_;

	my $maxid = $sql->SelectSingleValue("SELECT MAX($idcol) FROM $table")
		or return;
	print "Max=$maxid\n";

	@queries = map {
		sprintf($_, "SELECT $idcol FROM $table WHERE $idcol BETWEEN ? AND ?")
	} @queries;
	push @queries, "DELETE FROM $table WHERE $idcol BETWEEN ? AND ?";

	my $list = join ", ", sort($table, @$tables);

	my $done = 0;
	my ($min, $max) = (1, $chunk);
	my $lastmin = 0;
	while ($min <= $maxid)
	{
		$min = $sql->SelectSingleValue("SELECT MIN($idcol) FROM $table") || 0;
		if ($min == $lastmin)
		{
			print localtime() . " : Nibble failed - stuck at min=$min\n";
			return;
		}
		$lastmin = $min;

		$max = $min + $chunk - 1;
		check_loadavg();
		eval {
			$sql->Begin;
			$sql->Do("LOCK TABLE $list IN EXCLUSIVE MODE");
			for my $q (@queries)
			{
				print localtime() . " : $q ($min, $max)\n";
				$done += $sql->Do($q, $min, $max);
			}
			$sql->Commit;
		};
		if ($@) {
			warn $@;
			eval { $sql->Rollback };
		}
		$min += $chunk;
		$max += $chunk;
		if ($commit and $done >= $commit)
		{
			for my $dtab (@$tables, $table)
			{
				my $f = ($full ? " FULL" : "");
				print localtime() . " : VACUUM$f ANALYZE $dtab\n";
				$sql->{DBH}->do("VACUUM$f ANALYZE $dtab");
			}
			$done = 0;
		}
		sleep $sleep if defined $sleep;
	}

	print localtime() . " : Nibble complete\n";
}

exit 0;

sub check_loadavg
{
	my $la = loadavg();
	return if $la < $la_hwm;
	local $| = 1;
	print localtime() . " : Waiting for load average ($la) to fall ...";
	while (1)
	{
		sleep 10;
		$la = loadavg();
		print " $la";
		last if $la < $la_lwm;
	}
	print "\n";
	print localtime() . " : Continuing\n";
}

sub loadavg
{
	open(my $fh, "<", "/proc/loadavg") or return undef;
	my $line = <$fh>;
	close $fh;
	return (split ' ', $line)[0];
}

# eof RemovePrunedTRMs

<%perl>
# vi: set ts=4 sw=4 ft=mason :

# This component accepts a list of absolute times and converts each one to the
# user's preferred date/time format, in their preferred time zone.

# The input times can be in one of two formats: just an integer (seconds since
# the epoch), or in Postgres format: "2003-01-25 22:06:54.82141+00" (in which
# case, the seconds decimal point and everything following it will be
# ignored).  So in this case, make sure that the time values you're passing in
# are in UTC.

# Defaults
my $fmt = '%Y-%m-%d %H:%M:%S %Z';
my $tz = 'UTC';

# Use the session settings if available
$fmt = $session{"datetimeformat"} if $session{"datetimeformat"};
$tz = $session{"tz"} if $session{"tz"};

# Also allow overrides by passing a hash reference as the first parameter.
if (@_ and ref($_[0]) eq "HASH")
{
	my $opts = shift;
	$fmt = $opts->{"datetimeformat"} if $opts->{"datetimeformat"};
	$tz = $opts->{"tz"} if $opts->{"tz"};
}

require POSIX;

my @r = eval
{
	local $ENV{TZ};

	# Convert any stringy times into integers
	$ENV{TZ} = 'UTC';
	POSIX::tzset();

	for (@_)
	{
		my @bits = /\A(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)\b/;
		
		if (@bits)
		{
			$bits[0] -= 1900;
			--$bits[1];
			$_ = POSIX::mktime(reverse @bits);
		}
	}

	# Now convert the integers to the local formatted time
	$ENV{TZ} = $tz;
	POSIX::tzset();

	my @tzn = POSIX::tzname();
	my @fmt = ($fmt, $fmt);
	for (0,1) { $fmt[$_] =~ s/%Z/$tzn[$_]/g }

	map {
		my @l = localtime $_;
		POSIX::strftime($fmt[$l[8]], localtime($_));
	} @_;
};

my $err = $@;
POSIX::tzset();
die $err if $err;

return $r[-1] unless wantarray;
return(@r);

</%perl>

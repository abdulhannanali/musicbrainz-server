<%perl>
	# -----------------------------------------------------------------------------
	#                               Musicbrainz.org
	#                        Copyright (c) 2001 Robert Kaye
	# -----------------------------------------------------------------------------
	#  This software is provided "as is", without warranty of any kind, express or
	#  implied, including  but not limited  to the warranties of  merchantability,
	#  fitness for a particular purpose and noninfringement. In no event shall the
	#  authors or  copyright  holders be  liable for any claim,  damages or  other
	#  liability, whether  in an  action of  contract, tort  or otherwise, arising
	#  from,  out of  or in  connection with  the software or  the  use  or  other
	#  dealings in the software.
	#
	#  GPL - The GNU General Public License    http://www.gnu.org/licenses/gpl.txt
	#  Permits anyone the right to use and modify the software without limitations
	#  as long as proper  credits are given  and the original  and modified source
	#  code are included. Requires  that the final product, software derivate from
	#  the original  source or any  software  utilizing a GPL  component, such  as
	#  this, is also licensed under the GPL license.
	# -----------------------------------------------------------------------------
	#
	# Summary:
	# -----------------------------------------------------------------------------
	# Renders a relationship entity. If there is a pending edit on this
	# relationship, the output is highlighted using the "mp" css class.
	#
	# $Id$
	#
</%perl>
<%args>

	$item
	$index
	$name
    $release => 0
	$mb => undef

</%args>
<%perl>

	my $prefix = "link" . $index . "_";
	my $mp = $item->{modpending};

	my $e_id = $item->{$prefix . "id"};
	my $e_name = $item->{$prefix . "name"} eq "" ? $name : $item->{$prefix . "name"};
	my $e_type = $item->{$prefix . "type"};
	my $e_inttype = ($e_type eq "album" ? "release" : $e_type);

	my $url = $item->{$prefix . "name"};
	my $title = undef;
	my $strong = 0;
	my $shorten = 1;

	$m->out(qq!<span class="mp">!) if ($mp);

	if ($e_inttype eq "artist")
	{
		my ($sortname, $resolution) = ($item->{$prefix . "sortname"}, $item->{$prefix . "resolution"});
		$m->comp("/comp/linkartist", id => $e_id, name => $e_name, sortname => $sortname, resolution => $resolution);
	}
	elsif ($e_inttype eq "label")
	{
		my ($sortname, $resolution) = ($item->{$prefix . "sortname"}, $item->{$prefix . "resolution"});
		$m->comp("/comp/linklabel", id => $e_id, name => $e_name, sortname => $sortname, resolution => $resolution);
	}
	elsif ($e_inttype eq "release" or
		   $e_inttype eq "track")
	{
		$m->comp("/comp/link$e_inttype", id => $e_id, name => $e_name);

		if ($prefix eq "link1_")
		{
			# Add more info to make explicit the relationship
			#       le_artist                 ce_artist
			#          |                          |
			#   (linked_entity) <---AR---> (current_entity)
			#                                    ^^^^
			#                 entity we're outputing (release or track)

			# Entity we are outputing
			my ($current_entity, $ce_artist);
			if ($e_inttype eq "release")
			{
				$current_entity = MusicBrainz::Server::Release->new($mb->{DBH});
			}
			elsif ($e_inttype eq "track")
			{
				$current_entity = MusicBrainz::Server::Track->new($mb->{DBH});
			}
			$current_entity->SetId($e_id);
			$current_entity->LoadFromId();
			$ce_artist = $current_entity->GetArtist;
			
			# Entity at the other endpoint ("linked entity")
			my $lprefix = "link" . (1-$index) . "_";
			my $le_id = $item->{$lprefix . "id"};
			my $le_type = ($item->{$lprefix . "type"} eq "album" ? "release" : $item->{$lprefix . "type"});

			# Find the artist related to the linked entity
			my $le_artist = undef;
			if ($le_type eq "track" or $le_type eq "release")
			{
				my $linked_entity;
				if ($le_type eq "track")
				{
					$linked_entity = MusicBrainz::Server::Track->new($mb->{DBH});
				} 
				elsif ($le_type eq "release")
				{
					$linked_entity = MusicBrainz::Server::Release->new($mb->{DBH});
				}
				$linked_entity->SetId($le_id);
				$linked_entity->LoadFromId();
				$le_artist = $linked_entity->GetArtist;
			}
			elsif ($le_type eq "artist")
			{
				$le_artist = $le_id;
			}

			# Add "by <Artist>" to output, unless both artists are identical
			if ($le_artist ne $ce_artist)
			{
				my $artist = MusicBrainz::Server::Artist->new($mb->{DBH});
				$artist->SetId($ce_artist);
				$artist->LoadFromId();

				$m->out("&nbsp;by&nbsp;");
				$m->comp("/comp/linkartist", artist => $artist);
			}
		}		
	}
	elsif ($e_type eq "url")
	{
		my $name = $url;

		if ($item->{"link_name"} eq "amazon asin" && $prefix eq "link1_" && $release)
		{
			my ($asin, $coverart, $store);
			($asin, $coverart, $store) = MusicBrainz::Server::CoverArt->ParseAmazonURL($item->{link1_name}, $release);
			if ($asin ne "")
			{
			    $url = sprintf(qq!/misc/redirects/amazon-album-info.html?store=%s&amp;asin=%s!, $store, $asin);
			    $name = $asin;
			    $strong = 1;
			    $title = sprintf("Amazon page for ASIN %s on %s", $asin, $store);
			    $shorten = 0;
			}
		}
		elsif ($item->{"link_name"} eq "cover art link" && $prefix eq "link1_" && $release)
		{
			my ($coverurl);
			($name, $coverurl, $url) = MusicBrainz::Server::CoverArt->ParseCoverArtURL($item->{link1_name}, $release);
            if ($name ne '' && $coverurl eq '' && $url eq '')
            {
                $coverurl = $item->{link1_name};
            }
            elsif (!$url)
            {
                $url = $coverurl;
            }
            $release->SetCoverartURL($coverurl) if ($coverurl ne '');
			if ($url ne "")
			{
			    $strong = 1;
			    $title = "$name page";
			    $shorten = 0;
			}
		}
		elsif (($item->{"link_name"} eq "purchase for mail-order" ||
                $item->{"link_name"} eq "purchase for download" ||  
                $item->{"link_name"} eq "download for free" ||    
                $item->{"link_name"} eq "creative commons licensed download") && $prefix eq "link1_" && $release)
		{
            my ($coverurl);
            ($name, $coverurl, $url) = MusicBrainz::Server::CoverArt->ParseCoverArtURL($item->{link1_name}, $release);
            $release->SetInfoURL($url ne '' ? $url : $item->{link1_name}) if $release;
            $name = $item->{link1_name} if $url eq '';
		}
		else
		{
			if ($item->{"link_name"} eq "wikipedia" && $prefix eq "link1_")
			{
				$name =~ s/^http:\/\/(\w{2,})\.wikipedia\.org\/wiki\/(.*)$/$1: $2/o;
				$name =~ tr/_/ /;
				$shorten = 0;
			}

			# decode the URL
			use Encode;
			my $decoded_name = $name;
			$decoded_name =~ s/\%([\dA-Fa-f]{2})/pack('C', hex($1))/oeg;
			eval { Encode::decode_utf8($decoded_name, Encode::FB_CROAK); };
			$name = $decoded_name if !$@;
		}

		$m->comp("/comp/linkurl", id => $e_id, name => $name, href => $url, strong => $strong, title => $title, shorten => $shorten, modpending => $item->{$prefix."modpending"});
	}

	$m->out("</span>") if ($mp);

</%perl>
%return; # no final newline
%# vi: set ts=4 sw=4 ft=mason :

<%perl>
	# -----------------------------------------------------------------------------
	#                               Musicbrainz.org
	#                        Copyright (c) 2001 Robert Kaye
	# -----------------------------------------------------------------------------
	#  This software is provided "as is", without warranty of any kind, express or
	#  implied, including  but not limited  to the warranties of  merchantability,
	#  fitness for a particular purpose and noninfringement. In no event shall the
	#  authors or  copyright  holders be  liable for any claim,  damages or  other
	#  liability, whether  in an  action of  contract, tort  or otherwise, arising
	#  from,  out of  or in  connection with  the software or  the  use  or  other
	#  dealings in the software.
	#
	#  GPL - The GNU General Public License    http://www.gnu.org/licenses/gpl.txt
	#  Permits anyone the right to use and modify the software without limitations
	#  as long as proper  credits are given  and the original  and modified source
	#  code are included. Requires  that the final product, software derivate from
	#  the original  source or any  software  utilizing a GPL  component, such  as
	#  this, is also licensed under the GPL license.
	# -----------------------------------------------------------------------------
	#
	# Summary:
	# -----------------------------------------------------------------------------
	# Enter the edits of the Edit Release process
	#
	# $Id$
	#
</%perl>
<%args>

	$mb

	# make sure we have the needed parameters
	$artistid
	$releaseid
	$releasename

	# release attributes
	$attr_type
	$attr_status
	$attr_language
	$attr_script

	# number of tracks
	$tracks
	$hasmultipletrackartists

	# moderation note
	$notetext => ""

</%args>
<%perl>

	my $url = "/show/release/?releaseid=" . $releaseid;

	# load the original values for review
	my %orig;
	$orig{"mb"} = $mb;
	$orig{"releaseid"} = $releaseid;
	%orig = $m->comp("/comp/release_editor/init-editall", %orig);

	# Maintain a list of Artists cached by ID.
	my $GetCachedArtist = do
	{
		my %cache;
		sub
		{
			my ($id) = @_;
			return $cache{$id} if (exists $cache{$id});
			my $artist = $m->comp("/comp/loadartist", $mb, $id);
			return ($cache{$id} = $artist);
		};
	};

	$m->comp(
		"/comp/entermods",
		DBH => $mb->{DBH},
		sub => sub {
			my @mods;

			my $release = Album->new($mb->{DBH});
			$release->SetId($releaseid);
			$release->LoadFromId
				or die "Error loading release\n";

			my ($ov, $nv);

			# MOD_MOVE_ALBUM
			# if the album needs to be moved to an existing artist, or
			# if the insert mod above was successful, continue moving the
			# album to the newly created artist
			$ov = $orig{"artistid"};
			$nv = $ARGS{"artistid"};
			if ($ov ne $nv)
			{
				my $oldartist = &$GetCachedArtist($ov);
				my $newartist = &$GetCachedArtist($nv);
				push @mods, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_MOVE_ALBUM,
					# --
					album => $release,
					oldartist => $oldartist,
					artistid => $newartist->GetId,
					artistname => $newartist->GetName,
					artistsortname => $newartist->GetSortName,
				);
			}

			# MOD_EDIT_ALBUMNAME
			# Enter an edit if the releasename was edited
			$ov = $orig{"albumname"};
			$nv = $ARGS{"albumname"};
			if ($ov ne $nv)
			{
				push @mods, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_ALBUMNAME,
					# --
					album => $release,
					newname => $nv,
				);
			}

			# MOD_EDIT_ALBUMATTRS
			# Enter an edit if the album attributes were changed
			$ov = $orig{"attr_type"}.",".$orig{"attr_status"};
			$nv = $ARGS{"attr_type"}.",".$ARGS{"attr_status"};
			if ($ov ne $nv)
			{
				push @mods, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_ALBUMATTRS,
					# --
					albums => [ $release ],
					attr_type => $ARGS{"attr_type"},
					attr_status => $ARGS{"attr_status"},
				);
			}

			# MOD_EDIT_ALBUM_LANGUAGE
			# Enter an edit if the album language/script was changed
			$ov = $orig{"attr_language"}.",".$orig{"attr_script"};
			$nv = $ARGS{"attr_language"}.",".$ARGS{"attr_script"};
			if ($ov ne $nv)
			{
				push @mods, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_ALBUM_LANGUAGE,
					# --
					albums => [ $release ],
					language => $ARGS{"attr_language"},
					script => $ARGS{"attr_script"},
				);
			}

			# MOD_EDIT_RELEASES
			# get all defined release events from the arguments hash
			# and fill the list of new release objects
			require MusicBrainz::Server::Release;
			my @relnew;
			for my $j (sort map { /^rls_year-(\d+)$/ ? ($1) : () } keys %ARGS)
			{
				my $ry = $ARGS{"rls_year-$j"};
				my $rm = $ARGS{"rls_month-$j"};
				my $rd = $ARGS{"rls_day-$j"};
				my $rc = $ARGS{"rls_country-$j"};
				my $rid = $ARGS{"rls_id-$j"};

				# Skip if all blank
				next unless do { no warnings; "$rc $ry $rm $rd" =~ /\S/ };

				# Otherwise, we insist on a valid country and a valid date
				MusicBrainz::IsNonNegInteger($rc)
					or return $m->comp(
						"/comp/error",
						"Error: invalid release country entered",
						0, 1,
					);

				my @ymd = MusicBrainz::IsValidDate($ry, $rm, $rd)
					or next;

				my $rel = MusicBrainz::Server::Release->new($mb->{DBH});
				$rel->SetId($rid);
				$rel->SetCountry($rc);
				$rel->SetAlbum($releaseid);
				$rel->SetYMD(@ymd);
				push @relnew, $rel;
			}

			# get all defined release events.
			my @r = $release->Releases;
			my %relorig;
			for my $i (0 .. @r-1)
			{
				my $rel = $r[$i];
				$relorig{$rel->GetId} = $rel;
			}

			my (@adds, @edits, @removes);
			for my $i (0 .. @relnew-1)
			{
				my $rel = $relnew[$i];

				# old value is empty, and new value is not empty.
				# we've got an added release event
				if (!MusicBrainz::IsNonNegInteger($rel->GetId))
				{
					push @adds, $rel;
					next;
				}

				# for remove/edits of individual events, we'll need
				# a confirmed release event id. load object from the
				# database.
				my $obj = $relorig{$rel->GetId}
					or next;

				my @oymd = $obj->GetYMD;
				my @nymd = $rel->GetYMD;
				if ($oymd[0] != $nymd[0] or $oymd[1] != $nymd[1] or
					$oymd[2] != $nymd[2] or $obj->GetCountry != $rel->GetCountry)
				{
					push @edits, {
						object => $obj,
						country => $rel->GetCountry,
						year => $nymd[0],
						month => $nymd[1],
						day => $nymd[2],
					};
				}
				delete $relorig{$rel->GetId};
			}

			# add all edits which weren't handled above (e.g. which were deleted
			# from the form) to the @removes list.
			for my $relid (keys %relorig)
			{
				push @removes, $relorig{$relid};
			}

			# if any of the lists is non-empty, enter the MOD_EDIT_RELEASES edit.
			if (@adds or @edits or @removes)
			{
				push @mods, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_RELEASES,
					# --
					album	=> $release,
					adds	=> \@adds,
					edits	=> \@edits,
					removes	=> \@removes,
				);
			}

			# Enter edits for each track property that was changed.
			for (my $t=0; $t < $tracks; $t++)
			{
				# get original values
				my $orig_id = $orig{"trackid$t"} || "";
				my $orig_seq = $orig{"trackseq$t"};
				my $orig_track = $orig{"track$t"} || "";
				my $orig_length = $orig{"tracklength$t"} || "";
				my $orig_artistid = $orig{sprintf "tr%d_artistid", $t};
				my $oldartist = &$GetCachedArtist($orig_artistid);

				# get the new values
				my $new_id = $ARGS{"trackid$t"} || "";
				my $new_seq = $ARGS{"trackseq$t"};
				my $new_track = $ARGS{"track$t"} || "";
				my $new_length = $ARGS{"tracklength$t"} || "";
				my $new_delete = $ARGS{"trackdel$t"};
				my $new_artistid = $ARGS{sprintf "tr%d_artistid", $t};
				my $newartist = &$GetCachedArtist($new_artistid);

				# prepare Track object
				my $track = Track->new($mb->{DBH});
				$track->SetId($new_id);
				$track->SetAlbum($releaseid);
				$track->LoadFromId
					or die "Error loading track\n";

				# MOD_REMOVE_TRACK
				# Insert track removal edit if requested
				if ($new_delete)
				{
					push @mods, Moderation->InsertModeration(
						DBH	=> $mb->{DBH},
						uid	=> $session{uid},
						privs => $session{privs},
						type => &ModDefs::MOD_REMOVE_TRACK,
						# --
						track => $track,
						album => $release,
						# TODO depmod on $modid ?
					);
				}
				else
				{
					# MOD_EDIT_TRACKNUM
					if ($orig_seq ne $new_seq)
					{
						push @mods, Moderation->InsertModeration(
							DBH	=> $mb->{DBH},
							uid	=> $session{uid},
							privs => $session{privs},
							type => &ModDefs::MOD_EDIT_TRACKNUM,
							# --
							track => $track,
							newseq => $new_seq,
							# TODO depmod on $modid ?
						);
					}

					# MOD_CHANGE_TRACK_ARTIST
					if ($orig_artistid ne $new_artistid)
					{
						push @mods, Moderation->InsertModeration(
							DBH	=> $mb->{DBH},
							uid	=> $session{uid},
							privs => $session{privs},
							type => &ModDefs::MOD_CHANGE_TRACK_ARTIST,
							# --
							track => $track,
							oldartist => $oldartist,
							artistid => $newartist->GetId,
							artistname => $newartist->GetName,
							artistsortname => $newartist->GetSortName,
							# TODO depmod on $modid ?
						);
					}

					# MOD_ADD_TRACK_KV / MOD_EDIT_TRACKNAME
					# Insert add track name edit if the old name was "" and the new name is not ""
					# Insert edit track name edit if the old name was not ""
					if ($orig_track ne $new_track)
					{
						if ($orig_track eq "")
						{
							# make sure we don't insert empty new tracks.
							if ($new_track ne "")
							{
								push @mods, Moderation->InsertModeration(
									DBH	=> $mb->{DBH},
									uid	=> $session{uid},
									privs => $session{privs},
									type => &ModDefs::MOD_ADD_TRACK_KV,
									# --
									album => $release,
									trackname => $new_track,
									tracknum => $new_seq,
									tracklength => Track::UnformatTrackLength($new_length),
									artistid => $newartist->GetId,
								);
							}
						}
						else
						{
							push @mods, Moderation->InsertModeration(
								DBH	=> $mb->{DBH},
								uid	=> $session{uid},
								privs => $session{privs},
								type => &ModDefs::MOD_EDIT_TRACKNAME,
								# --
								track => $track,
								newname => $new_track,
							);
						}
					}

					# MOD_EDIT_TRACKTIME
					# Insert edit track length edit if requested
					if ($orig_length ne $new_length and
						$orig_track ne "")
					{
						push @mods, Moderation->InsertModeration(
							DBH	=> $mb->{DBH},
							uid	=> $session{uid},
							privs => $session{privs},
							type => &ModDefs::MOD_EDIT_TRACKTIME,
							# --
							track => $track,
							newlength => Track::UnformatTrackLength($new_length),
						);
					}
				}
			}

			if (@mods > 1)
			{
				my $num = @mods;
				$mods[0]->InsertNote(
					&ModDefs::MODBOT_MODERATOR,
					"The first of a set of $num edits",
					nosend => 1,
				);
				$mods[-1]->InsertNote(
					&ModDefs::MODBOT_MODERATOR,
					"The last of a set of $num edits",
					nosend => 1,
				);
			}

			# insert the edit note
			$mods[0]->InsertNote($session{'uid'}, $notetext)
				if $mods[0]
				and $notetext =~ /\S/;
		},
	) or return;

	$m->comp("/comp/redirect", $url);

</%perl>

%# vi: set ts=4 sw=4 ft=mason :
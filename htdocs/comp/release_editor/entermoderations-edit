<%perl>
	# -----------------------------------------------------------------------------
	#                               Musicbrainz.org
	#                        Copyright (c) 2001 Robert Kaye
	# -----------------------------------------------------------------------------
	#  This software is provided "as is", without warranty of any kind, express or
	#  implied, including  but not limited  to the warranties of  merchantability,
	#  fitness for a particular purpose and noninfringement. In no event shall the
	#  authors or  copyright  holders be  liable for any claim,  damages or  other
	#  liability, whether  in an  action of  contract, tort  or otherwise, arising
	#  from,  out of  or in  connection with  the software or  the  use  or  other
	#  dealings in the software.
	#
	#  GPL - The GNU General Public License    http://www.gnu.org/licenses/gpl.txt
	#  Permits anyone the right to use and modify the software without limitations
	#  as long as proper  credits are given  and the original  and modified source
	#  code are included. Requires  that the final product, software derivate from
	#  the original  source or any  software  utilizing a GPL  component, such  as
	#  this, is also licensed under the GPL license.
	# -----------------------------------------------------------------------------
	#
	# Summary:
	# -----------------------------------------------------------------------------
	# Enter the edits of the Edit Release process
	#
	# $Id$
	#
</%perl>
<%args>

	$mb

	# make sure we have the needed parameters
	$artistid
	$releaseid
	$releasename

	# release attributes
	$attr_type
	$attr_status
	$attr_language
	$attr_script

	# number of tracks
	$tracks
	$hasmultipletrackartists

	# moderation note
	$notetext => ""

</%args>
<%perl>

	my $url = "/show/release/?releaseid=" . $releaseid;

	# load the original values for review
	my %orig;
	$orig{"mb"} = $mb;
	$orig{"releaseid"} = $releaseid;
	%orig = $m->comp("/comp/release_editor/init-editall", %orig);

	# Maintain a list of Artists cached by ID.
	my $GetCachedArtist = do
	{
		my %cache;
		sub
		{
			my ($id) = @_;
			return $cache{$id} if (exists $cache{$id});
			my $artist = $m->comp("/comp/loadartist", $mb, $id);
			return ($cache{$id} = $artist);
		};
	};

	$m->comp(
		"/comp/entermods",
		DBH => $mb->{DBH},
		sub => sub {
			my @insertededits;

			my $release = Album->new($mb->{DBH});
			$release->SetId($releaseid);
			$release->LoadFromId
				or die "Error loading release\n";

			my ($ov, $nv);

			# only enter change track artist edits if either the release
			# artist hasn't changed and there are different there are
			# different track artists than the release artist.
			my $movetracks = 0;

			# MOD_MOVE_ALBUM
			# if the album needs to be moved to an existing artist, or
			# if the insert mod above was successful, continue moving the
			# album to the newly created artist
			$ov = $orig{"artistid"};
			$nv = $ARGS{"artistid"};
			if ($ov ne $nv)
			{
				my $oldartist = &$GetCachedArtist($ov);
				my $newartist = &$GetCachedArtist($nv);

				# if all tracks are set to the release artist, its a
				# single artist conversion, else a move release edit.
				$movetracks = 1;
				for (my $t=0; $t < $tracks; $t++)
				{
					my $orig_trackartistid = $orig{getField($t, "artistid")};
					my $new_trackartistid = $ARGS{getField($t, "artistid")};
					$movetracks = ($movetracks && $new_trackartistid == $nv);
				}

				push @insertededits, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_MOVE_ALBUM,
					# --
					album => $release,
					oldartist => $oldartist,
					artistid => $newartist->GetId,
					artistname => $newartist->GetName,
					artistsortname => $newartist->GetSortName,
					movetracks => $movetracks,
				);
			}

			# MOD_EDIT_ALBUMNAME
			# Enter an edit if the releasename was edited
			$ov = $orig{"releasename"};
			$nv = $ARGS{"releasename"};
			if ($ov ne $nv)
			{
				push @insertededits, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_ALBUMNAME,
					# --
					album => $release,
					newname => $nv,
				);
			}

			# MOD_EDIT_ALBUMATTRS
			# Enter an edit if the album attributes were changed
			$ov = $orig{"attr_type"}.",".$orig{"attr_status"};
			$nv = $ARGS{"attr_type"}.",".$ARGS{"attr_status"};
			if ($ov ne $nv)
			{
				push @insertededits, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_ALBUMATTRS,
					# --
					albums => [ $release ],
					attr_type => $ARGS{"attr_type"},
					attr_status => $ARGS{"attr_status"},
				);
			}

			# MOD_EDIT_ALBUM_LANGUAGE
			# Enter an edit if the album language/script was changed
			$ov = $orig{"attr_language"}.",".$orig{"attr_script"};
			$nv = $ARGS{"attr_language"}.",".$ARGS{"attr_script"};
			if ($ov ne $nv)
			{
				push @insertededits, Moderation->InsertModeration(
					DBH	=> $mb->{DBH},
					uid	=> $session{uid},
					privs => $session{privs},
					type => &ModDefs::MOD_EDIT_ALBUM_LANGUAGE,
					# --
					albums => [ $release ],
					language => $ARGS{"attr_language"},
					script => $ARGS{"attr_script"},
				);
			}

			# MOD_EDIT_RELEASES (RELEASE_EVENTS)
			# get all defined release events from the arguments hash
			# and fill the list of new release objects
			require MusicBrainz::Server::Release;
			my @revnew;
			my (@adds, @edits, @removes);
			for my $j (sort map { /^rev_year-(\d+)$/ ? ($1) : () } keys %ARGS)
			{
				my $rev_year = $ARGS{"rev_year-$j"};
				my $rev_month = $ARGS{"rev_month-$j"};
				my $rev_day = $ARGS{"rev_day-$j"};
				my $rev_country = $ARGS{"rev_country-$j"};
				my $rev_catno = $ARGS{"rev_catno-$j"};
				my $rev_barcode = $ARGS{"rev_barcode-$j"};
				my $rev_label = $ARGS{"rev_label-$j"};
				my $rev_format = $ARGS{"rev_format-$j"};
				my $rev_id = $ARGS{"rev_id-$j"};
				my $rev_clear = $ARGS{"rev_clear-$j"};

				$rev_year = "" if ($rev_year eq "yyyy");
				$rev_month = "" if ($rev_month eq "mm");
				$rev_day = "" if ($rev_day eq "dd");

				if (!$rev_clear)
				{
					# Do not validate if all fields are blank, or the
					# fields are blank and the release country is set to the default one.
					MusicBrainz::Server::Validation::TrimInPlace($rev_year, $rev_month, $rev_day, $rev_country);
					if (!($rev_year eq "" and $rev_month eq "" and $rev_day eq "" and
						 ($rev_country eq "" or $rev_country eq UserPreference::get("default_country"))))
					{
						# we insist on a valid country
						MusicBrainz::Server::Validation::IsNonNegInteger($rev_country)
							or return $m->comp("/comp/error",
								"Error: invalid release country",
								0, 1,
							);

						# we insist on a valid date
						my @ymd = MusicBrainz::Server::Validation::IsValidDate($rev_year, $rev_month, $rev_day)
							or return $m->comp("/comp/error",
								"Error: invalid release date",
								0, 1,
							);

						my $rev = MusicBrainz::Server::Release->new($mb->{DBH});
						$rev->SetId($rev_id);
						$rev->SetCountry($rev_country);
						$rev->SetYMD(@ymd);
						$rev->SetCatNo($rev_catno);
						$rev->SetBarcode($rev_barcode);
						$rev->SetLabel($rev_label);
						$rev->SetFormat($rev_format);
						$rev->SetAlbum($releaseid);
						push @revnew, $rev;
					}
				}
			}

			# get all defined release events.
			my @relEvents = $release->Releases;
			my %revorig;
			for my $i (0 .. @relEvents-1)
			{
				my $rev = $relEvents[$i];
				$revorig{$rev->GetId} = $rev;
			}


			for my $i (0 .. @revnew-1)
			{
				my $newrev = $revnew[$i];

				# old value is empty, and new value is not empty.
				# we've got an added release event
				if (!MusicBrainz::Server::Validation::IsNonNegInteger($newrev->GetId))
				{
					push @adds, $newrev;
					next;
				}

				# for remove/edits of individual events, we'll need
				# a confirmed release event id. load object from the
				# database.
				my $oldrev = $revorig{$newrev->GetId}
					or next;

				my @oymd = $oldrev->GetYMD;
				my @nymd = $newrev->GetYMD;
				if ($oymd[0] != $nymd[0] or $oymd[1] != $nymd[1] or
					$oymd[2] != $nymd[2] or $oldrev->GetCountry != $newrev->GetCountry or
					$oldrev->GetCatNo ne $newrev->GetCatNo or
					$oldrev->GetBarcode ne $newrev->GetBarcode or
					$oldrev->GetLabel != $newrev->GetLabel or
					$oldrev->GetFormat != $newrev->GetFormat)
				{
					push @edits, {
						object => $oldrev,
						country => $newrev->GetCountry,
						year => $nymd[0],
						month => $nymd[1],
						day => $nymd[2],
						catno => $newrev->GetCatNo,
						barcode => $newrev->GetBarcode,
						label => $newrev->GetLabel,
						format => $newrev->GetFormat,
					};
				}
				delete $revorig{$newrev->GetId};
			}

			# add all edits which weren't handled above (e.g. which were deleted
			# from the form) to the @removes list.
			for my $revid (keys %revorig)
			{
				push @removes, $revorig{$revid};
			}

			push @insertededits, Moderation->InsertModeration(
				DBH	=> $mb->{DBH},
				uid	=> $session{uid},
				privs => $session{privs},
				type => &ModDefs::MOD_ADD_RELEASEEVENTS,
				# --
				album => $release,
				adds => \@adds,
			) if (@adds);

			push @insertededits, Moderation->InsertModeration(
				DBH	=> $mb->{DBH},
				uid	=> $session{uid},
				privs => $session{privs},
				type => &ModDefs::MOD_EDIT_RELEASEEVENTS,
				# --
				album => $release,
				edits => \@edits,
			) if (@edits);

			push @insertededits, Moderation->InsertModeration(
				DBH	=> $mb->{DBH},
				uid	=> $session{uid},
				privs => $session{privs},
				type => &ModDefs::MOD_REMOVE_RELEASEEVENTS,
				# --
				album => $release,
				removes => \@removes,
			) if (@removes);

			# Enter edits for each track property that was changed.
			for (my $t=0; $t < $tracks; $t++)
			{
				# get original values
				my $orig_id = $orig{"trackid$t"};
				my $orig_seq = $orig{"trackseq$t"};
				my $orig_track = $orig{"track$t"};
				my $orig_length = $orig{"tracklength$t"};
				my $orig_artistid = $orig{sprintf "tr%d_artistid", $t};

				# get the new values
				my $new_id = $ARGS{"trackid$t"};
				my $new_seq = $ARGS{"trackseq$t"};
				my $new_track = $ARGS{"track$t"} || "";
				my $new_length = $ARGS{"tracklength$t"} || "";
				my $new_delete = $ARGS{"trackdel$t"};
				my $new_artistid = $ARGS{sprintf "tr%d_artistid", $t};

				# prepare Track object
				my $track;
				if ($new_id) 
				{
					$track = Track->new($mb->{DBH});
					$track->SetId($new_id);
					$track->SetAlbum($releaseid);
					$track->LoadFromId
						or die "Error loading track\n";
				}

				# MOD_REMOVE_TRACK
				# Insert track removal edit if requested
				if ($new_delete)
				{
					push @insertededits, Moderation->InsertModeration(
						DBH	=> $mb->{DBH},
						uid	=> $session{uid},
						privs => $session{privs},
						type => &ModDefs::MOD_REMOVE_TRACK,
						# --
						track => $track,
						album => $release,
						# TODO depmod on $modid ?
					);
				}
				else
				{
					# MOD_EDIT_TRACKNUM
					if (defined $orig_seq and $orig_seq ne $new_seq)
					{
						push @insertededits, Moderation->InsertModeration(
							DBH	=> $mb->{DBH},
							uid	=> $session{uid},
							privs => $session{privs},
							type => &ModDefs::MOD_EDIT_TRACKNUM,
							# --
							track => $track,
							newseq => $new_seq,
							# TODO depmod on $modid ?
						);
					}

					# MOD_CHANGE_TRACK_ARTIST
					if (defined $orig_artistid and $orig_artistid ne $new_artistid
						and not $movetracks)
					{
						my $oldartist = &$GetCachedArtist($orig_artistid);
						my $newartist = &$GetCachedArtist($new_artistid);
						push @insertededits, Moderation->InsertModeration(
							DBH	=> $mb->{DBH},
							uid	=> $session{uid},
							privs => $session{privs},
							type => &ModDefs::MOD_CHANGE_TRACK_ARTIST,
							# --
							track => $track,
							oldartist => $oldartist,
							artistid => $newartist->GetId,
							artistname => $newartist->GetName,
							artistsortname => $newartist->GetSortName,
							# TODO depmod on $modid ?
						);
					}

					# MOD_ADD_TRACK_KV / MOD_EDIT_TRACKNAME
					# Insert add track name edit if the old name was "" and the new name is not ""
					# Insert edit track name edit if the old name was not ""
					if ($orig_track ne $new_track)
					{
						if (!defined $orig_track)
						{
							# make sure we don't insert empty new tracks.
							if ($new_track ne "")
							{
								push @insertededits, Moderation->InsertModeration(
									DBH	=> $mb->{DBH},
									uid	=> $session{uid},
									privs => $session{privs},
									type => &ModDefs::MOD_ADD_TRACK_KV,
									# --
									album => $release,
									trackname => $new_track,
									tracknum => $new_seq,
									tracklength => Track::UnformatTrackLength($new_length),
									artistid => $new_artistid,
								);
							}
						}
						else
						{
							push @insertededits, Moderation->InsertModeration(
								DBH	=> $mb->{DBH},
								uid	=> $session{uid},
								privs => $session{privs},
								type => &ModDefs::MOD_EDIT_TRACKNAME,
								# --
								track => $track,
								newname => $new_track,
							);
						}
					}

					# MOD_EDIT_TRACKTIME
					# Insert edit track length edit if requested
					if (defined $orig_length and $orig_length ne $new_length)
					{
						push @insertededits, Moderation->InsertModeration(
							DBH	=> $mb->{DBH},
							uid	=> $session{uid},
							privs => $session{privs},
							type => &ModDefs::MOD_EDIT_TRACKTIME,
							# --
							track => $track,
							newlength => Track::UnformatTrackLength($new_length),
						);
					}
				}
			}

			if (@insertededits > 1)
			{
				my $num = @insertededits;
				$insertededits[0]->InsertNote(
					&ModDefs::MODBOT_MODERATOR,
					"The first of a set of $num edits",
					nosend => 1,
				);
				$insertededits[-1]->InsertNote(
					&ModDefs::MODBOT_MODERATOR,
					"The last of a set of $num edits",
					nosend => 1,
				);
			}

			# insert the edit note
			$insertededits[0]->InsertNote($session{'uid'}, $notetext)
				if $insertededits[0]
				and $notetext =~ /\S/;
		},
	) or return;

	$m->comp("/comp/redirect", $url);

</%perl>

%# vi: set ts=4 sw=4 ft=mason :

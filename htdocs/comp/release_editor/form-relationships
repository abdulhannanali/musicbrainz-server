<%perl>
	# -----------------------------------------------------------------------------
	#                               Musicbrainz.org
	#                        Copyright (c) 2001 Robert Kaye
	# -----------------------------------------------------------------------------
	#  This software is provided "as is", without warranty of any kind, express or
	#  implied, including  but not limited  to the warranties of  merchantability,
	#  fitness for a particular purpose and noninfringement. In no event shall the
	#  authors or  copyright  holders be  liable for any claim,  damages or  other
	#  liability, whether  in an  action of  contract, tort  or otherwise, arising
	#  from,  out of  or in  connection with  the software or  the  use  or  other
	#  dealings in the software.
	#
	#  GPL - The GNU General Public License    http://www.gnu.org/licenses/gpl.txt
	#  Permits anyone the right to use and modify the software without limitations
	#  as long as proper  credits are given  and the original  and modified source
	#  code are included. Requires  that the final product, software derivate from
	#  the original  source or any  software  utilizing a GPL  component, such  as
	#  this, is also licensed under the GPL license.
	# -----------------------------------------------------------------------------
	#
	# Summary:
	# -----------------------------------------------------------------------------
	# Render the release editor form
	#
	# $Id: form 8125 2006-07-10 19:20:04Z keschte $
	#
</%perl>
<%args>

	$mb
	
</%args>

	# write AR javascript config
	my $viewjs = 0;
	$m->out($viewjs ? '<pre>' : '<script type="text/javascript">');

	# try to create a link type object from the types (artist-track)
	my $linktype = MusicBrainz::Server::LinkType->newFromPackedTypes($mb->{DBH}, "artist-track");

	# try to create node from the relationship-id, else skip this node
	# (e.g. does not exist anymore)
	my $root = $linktype->Root;
	my $attrType = MusicBrainz::Server::LinkAttr->new($mb->{DBH});
	my $attr_root = $attrType->Root;
	my @children = $attr_root->Children;
	my %seen_attrs;


	# -------------------------------------------------------------------------
	# RELATIONSHIP TYPES
	# -------------------------------------------------------------------------

	# include non-selectable 0 element
	my @rel_types_ids;
	my @rel_types;
	push @rel_types, ("  0: { attr: '', desc: '', indent: 0, phrase: '[select a relationship type]' }");
	push @rel_types_ids, 0;

	# loop through all the types, and prepare javascript array
	my @q = map { [$_,0] } $root;
	while (my $l = shift @q)
	{
		unshift @q, map { [$_,$l->[1]+1] } $l->[0]->Children;
		next if ($l->[0]->GetName eq 'ROOT');
		if ($l->[0]->GetAttributes())
		{
			my @at = split ' ', $l->[0]->GetAttributes();
			foreach my $a (@at)
			{
				my ($key, $value) = split '=', $a;
				my ($mn, $mx) = split '-', $value;
				$mx = -1 if (!defined $mx or $mx eq '');
				$seen_attrs{$key} = $mx;
			}
		}
		my $phrase = $l->[0]->GetLinkPhrase;
		$phrase =~ s/\{(\w+:)/{/;

		# prepare list
		push @rel_types,
			sprintf("%d: { attr: '%s', desc: '%s', indent: %d, phrase: '%s' }",
				$l->[0]->GetId,
				$l->[0]->GetAttributes(),
				encode_entities($l->[0]->GetDescription()),
				$l->[1],
				encode_entities($phrase)
			);
		push @rel_types_ids, $l->[0]->GetId;
	}

	# include the list of toplevel types
	push @rel_types,
		sprintf("list: [%s]",
			join (", ", @rel_types_ids)
		);

	$m->out("// relationship types:\n");
	$m->out("var rel_types = {\n");
	$m->out(join (",\n  ", @rel_types));
	$m->out("\n};\n\n");

	# -------------------------------------------------------------------------
	# RELATIONSHIP ATTRIBUTES
	# -------------------------------------------------------------------------
	my @rel_attrs_ids;
	my @rel_attrs;
	foreach my $sec (keys %seen_attrs)
	{
		my $desc;
		my $isSimple;
		my $tree;
		foreach my $child (@children)
		{
			if ($child->GetName eq $sec)
			{
				$desc = $child->GetDescription;
				$isSimple = !$child->HasChildren;
				$tree = $child;
			}
		}

		# if we have a simple attribute type (=no children) print it
		push @rel_attrs, sprintf("%d: { name: '%s', desc: '%s', children: null }",
							$tree->GetId,
							encode_entities($sec),
							encode_entities($desc)
						) if ($isSimple);

		# else collect children, and print it
		if (!$isSimple)
		{
			my @children_list;
			my @children_ids;
			my @q = map { [$_,0] } $tree->Children;
			while (my $l = shift @q)
			{
				unshift @q, map { [$_, $l->[1]+1] } $l->[0]->Children;
				next if ($l->[0]->GetName eq 'ROOT');

				my $name = $l->[0]->GetName;
				MusicBrainz::Server::Validation::TrimInPlace($name);

				push @children_list, sprintf("%d: { indent: %d, name: '%s' }",
										$l->[0]->GetId,
										$l->[1],
										encode_entities($name));
				push @children_ids, $l->[0]->GetId;
			}
			push @children_list, sprintf("list: [%s]",
								join (", ", @children_ids));

			# encode children list into children array.
			my $children_dump = sprintf("\n    %s\n    ",
									join(", ", @children_list)
								);
			push @rel_attrs, sprintf("%d: { name: '%s', desc: '%s', children: {%s} }",
								$tree->GetId,
								$sec,
								$desc,
								$children_dump);
		}
		push @rel_attrs_ids, $tree->GetId;
	}

	# include the list of toplevel ids
	push @rel_attrs, sprintf(
						'"list": [%s]',
						join (", ", @rel_attrs_ids));
	push @rel_attrs, sprintf(
						'"list": [%s]',
						join (", ", @rel_attrs_ids));

	$m->out("// relationship attributes:\n");
	$m->out("var rel_attrs = {\n");
	$m->out(join (",\n  ", @rel_attrs));
	$m->out("\n};\n");

	$m->out($viewjs ? '</pre>' : '</script>');
	
%# vi: set ts=4 sw=4 ft=mason :

	
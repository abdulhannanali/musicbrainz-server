<%perl>
	# -----------------------------------------------------------------------------
	#                               Musicbrainz.org
	#                        Copyright (c) 2001 Robert Kaye
	# -----------------------------------------------------------------------------
	#  This software is provided "as is", without warranty of any kind, express or
	#  implied, including  but not limited  to the warranties of  merchantability,
	#  fitness for a particular purpose and noninfringement. In no event shall the
	#  authors or  copyright  holders be  liable for any claim,  damages or  other
	#  liability, whether  in an  action of  contract, tort  or otherwise, arising
	#  from,  out of  or in  connection with  the software or  the  use  or  other
	#  dealings in the software.
	#
	#  GPL - The GNU General Public License    http://www.gnu.org/licenses/gpl.txt
	#  Permits anyone the right to use and modify the software without limitations
	#  as long as proper  credits are given  and the original  and modified source
	#  code are included. Requires  that the final product, software derivate from
	#  the original  source or any  software  utilizing a GPL  component, such  as
	#  this, is also licensed under the GPL license.
	# -----------------------------------------------------------------------------
	#
	# Summary:
	# -----------------------------------------------------------------------------
	# Load the release from the database, and fill the %ARGS hash
	#
	# $Id$
	#
</%perl>
<%args>

	$mb
	$mbid => ""
	$releaseid => ""

</%args>
<%perl>

	my %orig = %ARGS;

	# LOAD RELEASE
	# ---------------------------------------------------------------
	my $release = Album->new($mb->{DBH});
	$release->SetId($releaseid);
	$release->SetMBId($mbid)
		if ($mbid ne "");

	# try loading the release
	if (not $release->LoadFromId(1))
	{
		$ARGS{"init-editall-error"} = sprintf "Release with <strong>id</strong> #%d not found in the database.", $release->GetId;
		return %ARGS;
	}

	# disallow editing the NAT-album
	if ($release->IsNonAlbumTracks)
	{
		$ARGS{"init-editall-error"} = sprintf "The 'Edit Release' feature cannot edit '%s'", &Album::NONALBUMTRACKS_NAME;
		return %ARGS;
	}
	$orig{"releaseid"} = $release->GetId;
	$orig{"releasename"} = $release->GetName;
	$orig{"attr_language"} = $release->GetLanguageId;
	$orig{"attr_script"} = $release->GetScriptId;
	($orig{"attr_type"}, $orig{"attr_status"}) = $release->GetReleaseTypeAndStatus;


	# LOAD ARTIST
	# ---------------------------------------------------------------
	# load release artist from database
	my $artist = Artist->new($mb->{DBH});
	$artist->SetId($release->GetArtist);
	if (not $artist->LoadFromId)
	{
		$ARGS{"init-editall-error"} = "Artist does not exist";
		return %ARGS;
	}
	$orig{"artistid"} = $artist->GetId;
	$orig{"artistname"} = $artist->GetName;

	# load tracks, and add into @t list.
	my $track_artist;
	my $i;
	my @t = $release->LoadTracks;
	$orig{"hasmultipletrackartists"} = $release->HasMultipleTrackArtists ? 1 : 0;
	for $i (0 .. @t-1)
	{
		my $tr = $t[$i];
		$orig{"trackid$i"} = $tr->GetId;
		$orig{"trackseq$i"} = $tr->GetSequence;
		$orig{"track$i"} = $tr->GetName;
		$orig{"tracklength$i"} = Track::FormatTrackLength($tr->GetLength);

		#$orig{sprintf "tr%d_id", $i} = $tr->GetId;
		#$orig{sprintf "tr%d_seq", $i} = $tr->GetSequence;
		#$orig{sprintf "tr%d_name", $i} = $tr->GetName;
		#$orig{sprintf "tr%d_length", $i} = Track::FormatTrackLength($tr->GetLength);
		$orig{sprintf "tr%d_mp", $i} = $tr->GetModPending;

		# load the artist object for the track
		# object, or use the release artist
		if ($orig{"hasmultipletrackartists"})
		{
			my $artistid = $tr->GetArtist;
			$artist->SetId($artistid);
			if (not $artist->LoadFromId)
			{
				$ARGS{"init-editall-error"} = "Track artist id='$artistid' does not exist";
				return %ARGS;
			}
		}
		$orig{sprintf "tr%d_artistid", $i} = $artist->GetId;
		$orig{sprintf "tr%d_artistname", $i} = $artist->GetName;
		$orig{sprintf "tr%d_artistresolution", $i} = $artist->GetResolution;

		# load the relationships for the track
		%orig = $m->comp(".GetRelationships", %orig, id => $tr->GetId, index => $i);
	}
	$orig{"tracks"} = @t;
	$orig{"v::edit_track_data"} = ($release->CanAddTrack or $release->CanRemoveTrack);

	# load releases, and add into @t list.
	my @r = $release->Releases;
	for $i (0 .. @r-1)
	{
		my $rel = $r[$i];
		my @ymd = $rel->GetYMD;

		$orig{"rls_id-$i"} = $rel->GetId;
		$orig{"rls_year-$i"} = $ymd[0];
		$orig{"rls_month-$i"} = $ymd[1] ? $ymd[1] : ""; # can possibly be 0 => ""
		$orig{"rls_day-$i"} = $ymd[2] ? $ymd[2] : ""; # can possibly be 0 => ""
		$orig{"rls_country-$i"} = $rel->GetCountry;
	}
	%orig = $m->comp("/comp/release_editor/check-releases", %orig);

	# either replace, or store original values
	# into ARGS hash.
	$ARGS{"v::orig"} = %orig;
	%ARGS = %orig
		if (!$ARGS{"v::formsubmitted"});

	# flag if the user can edit tracks needs to be loaded
	# from the original release every time
	$ARGS{"v::edit_track_data"} = $orig{"v::edit_track_data"};
	return %ARGS;

</%perl>



<%def .GetRelationships>
<%args>

	$mb
	$id
	$index
	$type => "track"

</%args>
<%perl>

	my ($item);
	my @links = MusicBrainz::Server::Link->FindLinkedEntities($mb->{DBH}, $id, $type);
	my $artist = undef;
	if (@links) {
		for $item (@links)
		{
			if ($item->{link0_type} ne $type || $item->{link0_id} != $id)
			{
				@$item{qw(
					link0_type			link1_type
					link0_id			link1_id
					link0_name			link1_name
					link_phrase			rlink_phrase
				)} = @$item{qw(
					link1_type			link0_type
					link1_id			link0_id
					link1_name			link0_name
					rlink_phrase		link_phrase
				)};
			}
		}
		@links = sort
		{
			my $c = $a->{link_phrase} cmp $b->{link_phrase};
			return $c if ($c);
			$c = $a->{enddate} cmp $b->{enddate};
			return $c if ($c);
			return $a->{begindate} cmp $b->{begindate};
		} @links;

		# load resolution if the relationship entity is an artist
		if ($item->{"link1_type"} eq "artist")
		{
			my $artistid = $item->{"link1_id"};

			# create an artist object, and load the resolution from
			# the database
			$artist = Artist->new($mb->{DBH}) if (not defined $artist);
			$artist->SetId($artistid);
			if (not $artist->LoadFromId)
			{
				$ARGS{"init-editall-error"} = "Artist id='$artistid' does not exist";
				return %ARGS;
			}
			$item->{"link1_resolution"} = $artist->GetResolution;
		}

		my $subindex = 0;
		for $item (@links)
		{
			# create link type.
			my $type = $item->{"link0_type"}."-".$item->{"link1_type"};
			my @types = sort split '-', $type;
			my $link = MusicBrainz::Server::Link->new($mb->{DBH}, \@types);
			my $node = $link->newFromId($item->{"link_id"});
			if ($node)
			{
				# strip spaces from values
				my $begindate = $item->{"begindate"};
				my $enddate = $item->{"enddate"};
				my $name = $item->{"link1_name"};
				my $resolution = $item->{"link1_resolution"};
				MusicBrainz::TrimInPlace($begindate, $enddate, $name, $resolution);

				# relationship parameters
				$ARGS{sprintf "tr%d_rel%d_nodeid", $index, $subindex} = $item->{"link_id"};
				$ARGS{sprintf "tr%d_rel%d_mp", $index, $subindex} = 1 if $item->{"modpending"};
				$ARGS{sprintf "tr%d_rel%d_typeid", $index, $subindex} = $node->GetLinkType();
				$ARGS{sprintf "tr%d_rel%d_begindate", $index, $subindex} = $begindate;
				$ARGS{sprintf "tr%d_rel%d_enddate", $index, $subindex} = $enddate;

				# related entity name, type and id
				$ARGS{sprintf "tr%d_rel%d_e_type", $index, $subindex} = $item->{"link1_type"};
				$ARGS{sprintf "tr%d_rel%d_e_id", $index, $subindex} = $item->{"link1_id"};
				$ARGS{sprintf "tr%d_rel%d_e_name", $index, $subindex} = $name;
				$ARGS{sprintf "tr%d_rel%d_e_resolution", $index, $subindex} = $resolution;

				# relationship attributes
				my $attrs = $item->{"_attrs"}->GetAttributes();
				if ($attrs)
				{
					foreach my $ref (@$attrs)
					{
						for(my $k = 0;; $k++)
						{
							my $key = sprintf("tr%d_rel%d_attr%d",
								$index,
								$subindex,
								$k
							);
							next if exists $ARGS{$key};
							$ARGS{$key} = $ref->{value};
							last;
						}
					}
				}
				++$subindex;
			}
		}
	}
	return %ARGS;

</%perl>
</%def>

%# vi: set ts=4 sw=4 ft=mason :
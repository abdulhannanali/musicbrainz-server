<& /comp/sidebar, 
   title=>'How does the MusicBrainz calculate CD Index Disc Ids?',
   expand=>'documentation' &>

<p>
Let us first have some words about how data is organized on a CD,
going top down.
</p>

<img src="images/cdhand.gif" align="left" border="0" alt="a compact disc">
<p>
A digital audio compact disc (CD-DA) can hold up to 99 audio tracks.
</p>

<p>
Sampling is done at a rate of 44.1 kHz using 16 bits resolution per channel, thus there are
44100 x 2 bytes x 2 channels (Stereo) = 176400 bytes of PCM data stored per second.
</p>

<p>
This audio data is contained in logical blocks of 2352 bytes each on the CD,
holding 2352 / 176400 = 1 / 75 seconds of sound.
</p>

<p>
A logical block plus 882 bytes of error correction and control data forms a raw
block of 3234 bytes that is spread among 98 frames of 33 bytes each that are
all together written on one spiral track among the CD.
</p>

<p>
At present we can stop at the level of logical blocks for our task.
The deeper stuff will be needed in case the CD-Text format becomes popular,
which stores extra data (like artist and track information) in the above 
mentioned control data parts.
</p>

<p>
Now let us have a look at a real world CD-DA.

Using a tool like
<a href="ftp://ftp.freebsd.org/pub/FreeBSD/FreeBSD-current/src/usr.sbin/cdcontrol/cdcontrol.c">
<tt>cdcontrol</tt></a>
(FreeBSD)
on
<a href="/showalbum.html?discid=MUtMmKN402WPj3_VFsgUelxpc8U-&amp;tracks=15&amp;toc=1+15+325882+150+18791+34817+56500+77156+106244+125879+149935+169035+186060+205979+230292+246809+265764+289629">this CD</a>
will yield:
</p>

<center>
<table width="95%" cellspacing="0" cellpadding="10" border="0"
       bgcolor="#efefff"
       summary="a closer look at a digital audio CD">
<tr>
<td>
<pre>
marc@oranje$ cdcontrol -f /dev/cd0c info

Starting track = 1, ending track = 15, TOC size = 4 bytes
track     start  duration   block  length   type
-------------------------------------------------
    1   0:02.00   4:10.41       0   18641  audio
    2   4:10.41   3:35.51   18641   16026  audio
    3   7:44.17   4:51.08   34667   21683  audio
    4  12:33.25   4:37.31   56350   20656  audio
    5  17:08.56   6:29.63   77006   29088  audio
    6  23:36.44   4:23.60  106094   19635  audio
    7  27:58.29   5:22.56  125729   24056  audio
    8  33:19.10   4:16.50  149785   19100  audio
    9  37:33.60   3:49.00  168885   17025  audio
   10  41:20.60   4:27.44  185910   19919  audio
   11  45:46.29   5:26.13  205829   24313  audio
   12  51:10.42   3:42.17  230142   16517  audio
   13  54:50.59   4:14.55  246659   18955  audio
   14  59:03.39   5:20.15  265614   23865  audio
   15  64:21.54   8:05.28  289479   36253   data
  170  72:25.07         -  325732       -      -
</pre>
</td>
</tr>
</table>
</center>

<p>
This is an example of a CD with an extra track of data (what you know as
CD-ROM), marketed in this case as CD-Extra, featuring a video and some 
pictures. (More precise: this is disc with two sessions, audio and data)
</p>

<p>
You should note the special track 170 (<tt>0xaa</tt>), that marks the beginning
of the leadout track, consisting of the remaining blocks on the CD.
</p>

<p>
The CD Index algorithm simply takes the following pieces of data
and runs them through the
<a href="http://www.w3.org/TR/1998/REC-DSig-label/SHA1-1_0">SHA-1</a>
hash function:
</p>

<ul>
<li> First track (normally one): 1 byte
<li> Last track: 1 byte
<li> Leadout track: 4 bytes
<li> 99 frame offsets: 4 bytes for each track.
     If there are less than 99 frame offsets (almost certainly),
     the value 0 will be used instead.
</ul>

<p>
Before the data is fed through the SHA-1 hash, it is converted to ASCII using
</p>

<center>
<table width="95%" cellspacing="0" cellpadding="10" border="0"
       bgcolor="#efefff"
       summary="1 byte hex output">
<tr>
<td>
<tt>printf("%02X", value);</tt>
</td>
</tr>
</table>
</center>

<p>
for byte values and
</p>

<center>
<table width="95%" cellspacing="0" cellpadding="10" border="0"
       bgcolor="#efefff"
       summary="4 byte hex output">
<tr>
<td>
<tt>printf("%08X", value);</tt>
</td>
</tr>
</table>
</center>

<p>
for 32 bit integer values.
</p>

<p>
Code is a better definition than English, so here is the code
that calculates the disc Id:
</p>

<center>
<table width="95%" cellspacing="0" cellpadding="10" border="0"
       bgcolor="#efefff"
       summary="CD Index Id algorithm">
<tr>
<td>
<pre>

sprintf(temp, "%02X", pCDInfo-&gt;FirstTrack);

sha_update(&amp;sha, (unsigned char*) temp, strlen(temp));

sprintf(temp, "%02X", pCDInfo-&gt;LastTrack);

sha_update(&amp;sha, (unsigned char*) temp, strlen(temp));

for (i = 0; i&lt;100; i++) {
    sprintf(temp, "%08X", pCDInfo-&gt;FrameOffset[i]);

    sha_update(&amp;sha, (unsigned char*) temp, strlen(temp));
}

sha_final(digest, &amp;sha);
</pre>
</td>
</tr>
</table>
</center>

<p>
Note that the leadout track is stored in <tt>pCDInfo-&gt;FrameOffset[0]</tt>.
</p>

<p>
The resulting 20 byte SHA-1 signature is converted to a base 64
encoded character ASCII string that is the disc Id.
</p>

<p>
One uses base 64 encoding to map arbitrary bytes onto a string of
printable ASCII characters.

It does this by redistributing the 24 bits of three 8-bit codes each into 
four 6-bit codes from a table of 64 very common ASCII characters.
</p>

<p>
Thus we end up with an Id string of 28 characters, in the above example
with "MUtMmKN402WPj3_VFsgUelxpc8U-".
</p>

<p>
Note: This base 64 string is not the same one specified in RFC822.
The RFC822 spec uses <tt>+</tt>, <tt>/</tt>, and <tt>=</tt> characters,
all of which are special HTTP/URL characters.

To avoid the problems with dealing with that, I (Rob) used <tt>.</tt>,
<tt>_</tt>, and <tt>-</tt>.
For details on this, please refer to <tt>base64.c</tt> in the source 
code.
</p>

<p>
This scheme has the advantage of being very simple (simple to
understand, simple to implement) and it is not ambigious.
</p>

<p>
However, two CDs pressings may not have the same Ids.

To handle this case, the CD Index system will let a user check to
see if the CD already exists in the system under a different Id.
If so, the system creates a new association for the different pressing
of the same CD.
</p>

<p>
If you'd like to know more about this, please
<a href="download.html">download</a>
the client source code and check it out.

The code is clean and self documenting.

If you are interested in creating other CD Index clients and need the SHA-1
source code, you can either dig through the CD Index source, or check the
<a href="http://www.w3.org/tr/1998/rec-dsig-label/sha1-1_0">W3C page</a> 
on SHA-1.
</p>

<p>
Note: The use of the MD5 algorithm has been discontinued in favour of
public domain SHA-1.
</p>

<p>
<font size="+1">Links</font>
</p>

<ul>
<li> The How Stuff Works site has a very readable 
     <a href="http://howstuffworks.com/cd.htm">introduction</a>
     on CD technology intended for the technically curious.
     Written by Marshall Brain.
<li> A superb coverage of CDs and formats on a scientific level
     is given by Prof Kelin J Kuhn from University of Washington. 
     Get the basics lecture  
     <a href="http://www.ee.washington.edu/conselec/CE/kuhn/cdaudio/95x6.htm">here</a> 
     and the format/encoding stuff lecture
     <a href="http://www.ee.washington.edu/conselec/CE/kuhn/cdaudio2/95x7.htm">here</a>.
<li> There is actually a very fine 
     <a href="http://www.fadden.com/cdrfaq">FAQ about toasting</a>
     available that has lots of interesting facts. 
     Written by Andy McFadden.
<li> Find out more about how CD-DA and CD-ROM formats have been enhanced
     through 
     <a href="http://www.discmfg.com/PDF/enhanced.pdf">this</a>
     PDF document provided by Cinram.
<li> Another introduction from Kelin Kuhn can be found
     <a href="http://www.ee.washington.edu/class/ConsElec/cd.html">here</a>,
     again at University of Washington Electrical Engineering.
<!--<li> The folks over at Hewlett-Packard have
     <a href="http://www.hp.com/isgsupport/cdr/devkit/techover.htm">these</a>
     technical bits for you.-->
</ul>

<& /comp/footer &>

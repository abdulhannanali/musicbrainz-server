%# vi: set ts=2 sw=2 ft=mason :
<%args>
$link0 => -1
$link1 => -1
$linktypeid => undef
$notetext => undef
$begindate_y => ''
$begindate_m => ''
$begindate_d => ''
$enddate_y => ''
$enddate_m => ''
$enddate_d => ''
$submit=>0
$swap=>''
</%args>
<%perl>

$m->comp("/comp/checkloggedin", 1, 1)
    or return;

if ($link0 < 0 || $link1 < 0)
{
    $m->comp("/comp/error", "You must select two elements before you can create a relationship." , 1, 1);
    return;
}
my @links = @ARGS{qw( link0 link1 )};

my $mb = $m->comp("/comp/dblogin");

for my $ref (\(@links))
{
    my ($type, $id) = $$ref =~ /\A(\w+)=(\d+)\z/
        or die "? $$ref";
    MusicBrainz::Server::LinkEntity->IsValidType($type)
        or die;

    my $obj = MusicBrainz::Server::LinkEntity->newFromTypeAndId(
        $mb->{DBH},
        $type, $id,
    ) or die;

    $$ref = {
        type => $type,
        id => $id,
        obj => $obj,
        name => $obj->GetName,
    };
}

if ($links[0]->{type} ne $links[1]->{type})
{
    # Sort the links in the right order
    @links = sort { $a->{type} cmp $b->{type} }  @links;
}
elsif ($swap)
{
    my $temp = $links[0];
    $links[0] = $links[1];
    $links[1] = $temp;
}

my @types = map { $_->{type} } @links;

# Sanity check... this should be fine
MusicBrainz::Server::LinkEntity->ValidateTypes(\@types)
    or die;

my ($attributes, $desc);
($linktypeid, $attributes, $desc) = split '\|', $linktypeid if ($linktypeid);

my $link = MusicBrainz::Server::LinkType->new($mb->{DBH}, \@types);

# Load the top level link attributes
my $attrType = MusicBrainz::Server::LinkAttr->new($mb->{DBH});
my $attr_root = $attrType->Root;
my @children = $attr_root->Children;

my @submit_attr;
my $attr_error = "";

for my $kvpair (split ' ', $attributes)
{
	my ($name, $limits) = split '=', $kvpair;
	my ($mn, $mx) = split '-', $limits;

	$mn = 0 if (!defined $mn or $mn eq '');
	$mx = 1000 if (!defined $mx or $mx eq '');

    my $total = 0;
    for(my $index = 0; $index < $mx; $index++)
    {
        # First, check to see if we have a passed arg
        last if (!exists $ARGS{"attr_".$name."_".$index});
        my $value = $ARGS{"attr_".$name."_".$index};
        if ($value)
        {
            if ($value < 0)
            {
                my $lookupAttr = $attrType->newFromParentIdAndChildName(0, $name);
                $value = ($lookupAttr) ?  $lookupAttr->GetId() : 0;
            }
            $total++;
	        push @submit_attr, { value=>$value, name=>$name };
        }
    }

    if ($total > $mx && $mx >= 0)
    {
        # This should never happen
        $attr_error .= "Too many selections made for attribute '$name'.<br/>";
    }
    elsif ($total == 0 && $mn == 1)
    {
        $attr_error .= "No selection made for required attribute '$name'.<br/>";
    }
    elsif ($total < $mn)
    {
        $attr_error .= "Too few selections for attribute '$name'.<br/>";
    }
}

if (!$swap
    and !$attr_error
		and $desc
    and ($linktypeid =~ /^\d+$/)
    and MusicBrainz::IsValidDateOrEmpty($begindate_y, $begindate_m, $begindate_d)
    and MusicBrainz::IsValidDateOrEmpty($enddate_y, $enddate_m, $enddate_d)
    and MusicBrainz::IsDateEarlierThan($begindate_y, $begindate_m, $begindate_d,
                                       $enddate_y, $enddate_m, $enddate_d))
{
    my $linktype = $link->newFromId($linktypeid);
    if ($linktype)
    {
        # Remove the two entities being linked from recent_links
				if (UserPreference::get('remove_recent_link_on_add'))
				{
					my $recent_links = ($session{recent_links} ||= []);
					@$recent_links = grep {
							($_->[0] != $links[0]{type} || $_->[1] != $links[0]{id}) &&
							($_->[0] != $links[1]{type} || $_->[1] != $links[1]{id})
					} @$recent_links;
					$session{recent_links} = $recent_links;
				}

				# So far, always redirects back to the "first" link
        my $url = "/showrel.html?type=" . $links[0]{type} . "&id=" . $links[0]{id};

        $m->comp(
            "/comp/entermods",
            DBH => $mb->{DBH},
            sub => sub {
                my @mods = Moderation->InsertModeration(
                    DBH       => $mb->{DBH},
                    uid       => $session{uid},
                    privs     => $session{privs},
                    type      => &ModDefs::MOD_ADD_LINK,
                    # --
                    entities  => \@links,
                    linktype  => $linktype,
                    begindate => [ $begindate_y, $begindate_m, $begindate_d ],
                    enddate   => [ $enddate_y, $enddate_m, $enddate_d ],
										attributes=> \@submit_attr,
                );

                $mods[0]->InsertNote($session{'uid'}, $notetext)
                    if $mods[0]
                    and $notetext =~ /\S/;
            },
            success_url => $url,
        ) or return;
    }
}

my $root = $link->Root;

my $rev = ($links[0]->{type} eq 'album' && $links[1]->{type} eq 'artist') ? 1 : 0;

my %seen_attrs;

</%perl>
<& /comp/sidebar, title => 'Create Relationship: Select relationship type' &>

% if (UserStuff->IsLinkModerator($session{privs})) {
    <div> [
        <a href="/edit/relationships/link_type_roots.html">Edit relationship types</a>
    ] </div>
% }

% if ($submit && !$swap) {
%     if (!$linktypeid) {
			<div class="linkerror">Error: You must select a relationship type.</div>
%     }
%     if (!MusicBrainz::IsValidDateOrEmpty($begindate_y, $begindate_m, $begindate_d)) {
			<div class="linkerror">Error: You entered an invalid start date.</div>
%     }
%     if (!MusicBrainz::IsValidDateOrEmpty($enddate_y, $enddate_m, $enddate_d)) {
			<div class="linkerror">Error: You entered an invalid end date.</div>
%     }
%     if (!MusicBrainz::IsDateEarlierThan($begindate_y, $begindate_m, $begindate_d, $enddate_y, $enddate_m, $enddate_d)) {
			<div class="linkerror">Error: Your end date is before your begin date.</div>
%     }
%     if ($attr_error) {
			<div class="linkerror">Error: <% $attr_error |n %></div>
%     }
%     if (!$desc && $linktypeid) {
			<div class="linkerror">Error: Please select a subtype of the currently
				selected relationship type. The selected relationship type is only
				used for grouping sub-types.</div>
%     }
% }
<p>

</p>

<script language="javascript" src="/scripts/ar-attributesearch.js"></script>
<form method="post" name="linkselect" action="/edit/relationship/add.html">
	<fieldset>
    	<legend>Select the relationship type for a <% $links[$rev?1:0]->{type} %>-<% $links[$rev?0:1]->{type} %> relationship</legend>
		<table>
			<tr>
				<td width="150"><label><% ucfirst($links[$rev?1:0]{type}) %>: </label></td>
				<td colspan="2" id="arlinkswap-link<%$rev?1:0%>-td"><a href="/show<% $links[$rev?1:0]{type} %>.html?<% $links[$rev?1:0]{type} %>id=<% $links[$rev?1:0]{id} %>"><b><% $links[$rev?1:0]{name} %></b></a></td>
			</tr>
			<tr>
				<td>&nbsp;</td>
				<td>
					<select name="linktypeid" id="linktypeid" onKeyDown="ar_typeChanged()" onChange="ar_typeChanged()">
						<option value="||">[select a relationship type]</option>
						<%perl>
						my @q = map { [$_,0] } $root;
						while (my $l = shift @q)
						{
							unshift @q, map { [$_,$l->[1]+1] } $l->[0]->Children;
							next if ($l->[0]->GetName eq 'ROOT');
							if ($l->[0]->GetAttributes())
							{
								my @at = split ' ', $l->[0]->GetAttributes();
								foreach my $a (@at)
								{
									my ($key, $value) = split '=', $a;
									my ($mn, $mx) = split '-', $value;
									$mx = -1 if (!defined $mx or $mx eq '');
									$seen_attrs{$key} = $mx;
								}
							}
						</%perl>
						<option value="<% $l->[0]->GetId %>|<% $l->[0]->GetAttributes() %>|<% $l->[0]->GetDescription() %>" <% $l->[0]->GetId eq $linktypeid ? 'selected=""' : '' %>
%							my $text = $rev ? $l->[0]->GetReverseLinkPhrase : $l->[0]->GetLinkPhrase;
%							$text =~ s/\{(\w+:)/{/;
							><% ("&nbsp;&nbsp;" x $l->[1]) |n %><% $text %>&nbsp;&nbsp;</option>
%						}
					</select></td>
					<td>
% if ($links[0]{type} eq $links[1]{type}) {
						<div id="swap-clientside" style="display: none">
							<input type="button" class="button" onclick="ar_swapElements(this)" name="swapJS" value="Change direction">
						</div>
						<div id="swap-serverside" style="display: block">
							<input type="submit" class="button" name="swap" value="Change direction">
						</div>
% }
					</td>
			</tr>
			<tr>
				<td><label><% ucfirst($links[$rev?0:1]{type}) %>: </label></td>
				<td colspan="2" id="arlinkswap-link<%$rev?0:1%>-td"><a href="/show<% $links[$rev?0:1]{type} %>.html?<% $links[$rev?0:1]{type} %>id=<% $links[$rev?0:1]{id} %>"><b><% $links[$rev?0:1]{name} %></b></a></td>
			</tr>
		</table>

		<table>
			<tr valign="top">
				<td valign="top" width="150"><label>Description:</label></td>
				<td><span id="relationship_desc" class="linkdesc">&nbsp;</span></td>
			</tr>
		</table>

		<div id="attributes">
			<div class="padtop"></div>
			<table>
				<tr>
					<td valign="top" width="150">
					 	<label>Attributes:</label></td>
					<td>
						<%perl>
						foreach my $sec (keys %seen_attrs)
						{
							my $desc;
							my $isSimple;
							my $tree;
							foreach my $child (@children)
							{
								if ($child->GetName eq $sec)
								{
									$desc = $child->GetDescription;
									$isSimple = !$child->HasChildren;
									$tree = $child;
								}
							}
							$m->out(qq|<div id="$sec" class="ar-attribute">|);
							for(my $index = 0;; $index++)
							{
								last if ($index > 0 && !exists $ARGS{"attr_". $sec . "_$index"});
								if ($isSimple)
								{
									$m->out(qq|<input type="checkbox" name="attr_|. $sec . "_" . qq|$index" value="| . $tree->GetId . "\"");
									$m->out(qq| checked=""|) if ($ARGS{"attr_$sec"."_$index"});
									$m->out(qq|> <i>$sec</i>|);
								}
								else
								{
									$m->out(qq|<div id="attr_|. $sec . "_" . $index . qq|_item" class="ar-attribute-item">\n|);
									$m->out(qq|<select name="attr_|. $sec . "_" . qq|$index" id="attr_|. $sec . "_" . qq|$index" class="ar-dropdown" onFocus="dds_onFocus(this)">\n|);
									$m->out(qq|<option value="">&nbsp;[select $sec]</option>\n|);
									my @q = map { [$_,0] } $tree->Children;
									while (my $l = shift @q)
									{
										unshift @q, map { [$_,$l->[1]+1] } $l->[0]->Children;
										next if ($l->[0]->GetName eq 'ROOT');
										$m->out("<option value=\"".$l->[0]->GetId.'" ');
										$m->out($l->[0]->GetId eq $ARGS{"attr_".$sec."_$index"} ? 'selected=""' : '');
										$m->out(">&nbsp;" . ("&nbsp;&nbsp;" x $l->[1]) . $l->[0]->GetName . "</option>\n");
									}
									$m->out("</select>");
									$m->out(qq|<script language="javascript"> dds_writeUI('$sec', '$index') </script>\n|);
									$m->out("</div>");
								}
							}
							$m->out(qq|</div>\n|);
							$m->out(qq|<div id="$sec-desc" class="ar-attribute-description">$desc\n|);
							$m->out(qq|<p style="margin: 0"><input type="button" onClick="dds_addAttribute('$sec')" value="Add another $sec" />\n|)  if ($seen_attrs{$sec} < 0 || $seen_attrs{$sec} > 1);
							$m->out(qq|</div>\n|);
						}
						</%perl>
						<noscript>
							NOTE: You do not have JavaScript enabled. Not all of the attributes shown above apply
							to all relationship types and without JavaScript we cannot selectively display
							the appropriate attributes. We recommend that you turn on JavaScript in your browser.
						</noscript>
					</td>
				</tr>
			</table>
		</div>

		<div class="padtop"></div>
		<table>
			<tr>
				<td width="150"><label for="addrel_begindate">Begin date:</label></td>
				<td>
					<& /comp/dateinput, name_prefix => 'begindate', value=> [$begindate_y, $begindate_m, $begindate_d],
						id => "addrel_begindate" &>
					Year-Month-Day</td>
			</tr>
			<tr>
				<td><label for="addrel_enddate">End date:</label></td>
				<td>
					<& /comp/dateinput, name_prefix => 'enddate', value=>[$enddate_y, $enddate_m, $enddate_d],
						id => "addrel_enddate" &>
					Year-Month-Day</td>
			</tr>
			<tr>
				<td></td>
				<td>
					<div class="ar-attribute-description">
					If the relationship type you selected indicates a temporal relationship (e.g. <i>was a member of</i>), then enter
					the begin and/or end dates below. These dates are optional, and leaving the end date blank
					indicates that this relationship is still active today:</div></td>
			</tr>
		</table>

		<div class="padlefttop">
			<& /comp/notetext, text => $notetext &>
		</div>
		<div class="padlefttop">
			<input type="hidden" name="link0" value="<% sprintf("%s=%d", $links[0]->{type}, $links[0]->{id}) %>">
			<input type="hidden" name="link1" value="<% sprintf("%s=%d", $links[1]->{type}, $links[1]->{id}) %>">
			<input type="submit" class="button" value="Submit">
			<input type="hidden" name="submit" value="1">
			<input type="hidden" name="isurlform" value="0">
		</div>
	</fieldset>
</form>

<script type="text/javascript">
<!--
	var wasFormSubmitted = <% $submit %>;
	<%perl>
		print "var attributeDivs = new Array(";
		foreach my $sec (keys %seen_attrs) {
			print "'".$sec."',";
		}
		print "null);\n";
	</%perl>
-->
</script>
<script language="javascript" src="/scripts/ar-frontend.js"></script>

<& /comp/footer &>

%# vi: set ts=2 sw=2 ft=mason :
<%args>
$link0 => -1
$link1 => -1
$linktypeid => undef
$notetext => undef
$begindate_y => ''
$begindate_m => ''
$begindate_d => ''
$enddate_y => ''
$enddate_m => ''
$enddate_d => ''
$submit=>0
$swap=>''
</%args>
<%perl>

$m->comp("/comp/checkloggedin", 1, 1)
    or return;

if ($link0 < 0 || $link1 < 0)
{
    $m->comp("/comp/error", "You must select two elements before you can create a relationship." , 1, 1);
    return;
}
my @links = @ARGS{qw( link0 link1 )};

my $mb = $m->comp("/comp/dblogin");

for my $ref (\(@links))
{
    my ($type, $id) = $$ref =~ /\A(\w+)=(\d+)\z/
        or die "? $$ref";
    MusicBrainz::Server::LinkEntity->IsValidType($type)
        or die;

    my $obj = MusicBrainz::Server::LinkEntity->newFromTypeAndId(
        $mb->{DBH},
        $type, $id,
    ) or die;

    $$ref = {
        type => $type,
        id => $id,
        obj => $obj,
        name => $obj->GetName,
    };
}

if ($links[0]->{type} ne $links[1]->{type})
{
    # Sort the links in the right order
    @links = sort { $a->{type} cmp $b->{type} }  @links;
}
elsif ($swap)
{
    my $temp = $links[0];
    $links[0] = $links[1];
    $links[1] = $temp;
}

my @types = map { $_->{type} } @links;

# Sanity check... this should be fine
MusicBrainz::Server::LinkEntity->ValidateTypes(\@types)
    or die;

my ($attributes, $desc);
($linktypeid, $attributes, $desc) = split '\|', $linktypeid if ($linktypeid);

my $link = MusicBrainz::Server::LinkType->new($mb->{DBH}, \@types);

# Load the top level link attributes
my $attrType = MusicBrainz::Server::LinkAttr->new($mb->{DBH});
my $attr_root = $attrType->Root;
my @children = $attr_root->Children;

my @submit_attr;
my $attr_error = "";

for my $kvpair (split ' ', $attributes)
{
	my ($name, $limits) = split '=', $kvpair;
	my ($mn, $mx) = split '-', $limits;

	$mn = 0 if (!defined $mn or $mn eq '');
	$mx = 1000 if (!defined $mx or $mx eq '');
	
    my $total = 0;
    for(my $index = 0; $index < $mx; $index++)
    {
        # First, check to see if we have a passed arg
        last if (!exists $ARGS{"attr_".$name."_".$index});
        my $value = $ARGS{"attr_".$name."_".$index};
        if ($value)
        {
            if ($value < 0)
            {
                my $lookupAttr = $attrType->newFromParentIdAndChildName(0, $name);
                $value = ($lookupAttr) ?  $lookupAttr->GetId() : 0;
            }
            $total++;
	        push @submit_attr, { value=>$value, name=>$name };
        }
    }

    if ($total > $mx && $mx >= 0)
    {
        # This should never happen
        $attr_error .= "Too many selections made for attribute '$name'.<br/>";
    }
    elsif ($total == 0 && $mn == 1)
    {
        $attr_error .= "No selection made for required attribute '$name'.<br/>";
    }
    elsif ($total < $mn)
    {
        $attr_error .= "Too few selections for attribute '$name'.<br/>";
    }
}

if (!$swap 
    and !$attr_error
		and $desc
    and ($linktypeid =~ /^\d+$/)
    and MusicBrainz::IsValidDateOrEmpty($begindate_y, $begindate_m, $begindate_d)
    and MusicBrainz::IsValidDateOrEmpty($enddate_y, $enddate_m, $enddate_d)
    and MusicBrainz::IsDateEarlierThan($begindate_y, $begindate_m, $begindate_d,
                                       $enddate_y, $enddate_m, $enddate_d))
{
    my $linktype = $link->newFromId($linktypeid);
    if ($linktype)
    {
        # Remove the two entities being linked from recent_links
				if (UserPreference::get('remove_recent_link_on_add'))
				{
					my $recent_links = ($session{recent_links} ||= []);
					@$recent_links = grep {
							($_->[0] != $links[0]{type} || $_->[1] != $links[0]{id}) &&
							($_->[0] != $links[1]{type} || $_->[1] != $links[1]{id})
					} @$recent_links;
					$session{recent_links} = $recent_links;
				}

				# So far, always redirects back to the "first" link
        my $url = "/showrel.html?type=" . $links[0]{type} . "&id=" . $links[0]{id};

        $m->comp(
            "/comp/entermods",
            DBH => $mb->{DBH},
            sub => sub {
                my @mods = Moderation->InsertModeration(
                    DBH       => $mb->{DBH},
                    uid       => $session{uid},
                    privs     => $session{privs},
                    type      => &ModDefs::MOD_ADD_LINK,
                    # --
                    entities  => \@links,
                    linktype  => $linktype,
                    begindate => [ $begindate_y, $begindate_m, $begindate_d ],
                    enddate   => [ $enddate_y, $enddate_m, $enddate_d ],
										attributes=> \@submit_attr,
                );

                $mods[0]->InsertNote($session{'uid'}, $notetext)
                    if $mods[0]
                    and $notetext =~ /\S/;
            },
            success_url => $url,
        ) or return;
    }
}

my $root = $link->Root;

my $rev = ($links[0]->{type} eq 'album' && $links[1]->{type} eq 'artist') ? 1 : 0;

my %seen_attrs;

</%perl>
<& /comp/sidebar, title => 'Create Relationship: Select Link Type' &>

% if (UserStuff->IsLinkModerator($session{privs})) {
    <div class="LinksRow"> [
        <a href="/edit/relationships/link_type_roots.html">Edit link types</a>
    ] </div>
% }

% if ($submit && !$swap) {
%     if (!$linktypeid) {
			<div class="linkerror">Error: You must select a link type.</div>
%     }
%     if (!MusicBrainz::IsValidDateOrEmpty($begindate_y, $begindate_m, $begindate_d)) {
			<div class="linkerror">Error: You entered an invalid start date.</div>
%     }
%     if (!MusicBrainz::IsValidDateOrEmpty($enddate_y, $enddate_m, $enddate_d)) {
			<div class="linkerror">Error: You entered an invalid end date.</div>
%     }
%     if (!MusicBrainz::IsDateEarlierThan($begindate_y, $begindate_m, $begindate_d, $enddate_y, $enddate_m, $enddate_d)) {
			<div class="linkerror">Error: Your end date is before your begin date.</div>
%     }
%     if ($attr_error) {
			<div class="linkerror">Error: <% $attr_error |n %></div>
%     }
%     if (!$desc && $linktypeid) {
			<div class="linkerror">Error: Please select a subtype of the currently 
				selected link type. The selected link type is only used for grouping sub-types.</div>
%     }
% }
<p>

</p>

<form method="post" name="linkselect" action="/edit/relationship/add.html">
	<fieldset>
% if ($rev) {
    	<legend>Select the link type for a <% ucfirst($links[1]->{type}) %>-<% ucfirst($links[0]->{type}) %> link</legend>
% } else {
    	<legend>Select the link type for a <% ucfirst($links[0]->{type}) %>-<% ucfirst($links[1]->{type}) %> link</legend>
% }

		<table>
			<tr>
% if ($rev) {
				<td width="150" id="arlinkswap-link0-td">
					<label><% ucfirst($links[1]{type}) %> <a href="/show<% $links[1]{type} %>.html?<% $links[1]{type} %>id=<% $links[1]{id} %>"><b><% $links[1]{name} %></b></a></label></td>
% } else {
				<td width="150" id="arlinkswap-link0-td">
					<label><% ucfirst($links[0]{type}) %> <a href="/show<% $links[0]{type} %>.html?<% $links[0]{type} %>id=<% $links[0]{id} %>"><b><% $links[0]{name} %></b></a></label></td>
% }					
				<td>
					<select name="linktypeid" id="linktypeid" onKeyDown="linkTypeChanged()" onChange="linkTypeChanged()">
						<option value="||">[select a link type]</option>
						<%perl>
						my @q = map { [$_,0] } $root;
						while (my $l = shift @q) 
						{
							unshift @q, map { [$_,$l->[1]+1] } $l->[0]->Children;
							next if ($l->[0]->GetName eq 'ROOT');
							if ($l->[0]->GetAttributes()) 
							{
								my @at = split ' ', $l->[0]->GetAttributes();
								foreach my $a (@at)
								{
									my ($key, $value) = split '=', $a;
									my ($mn, $mx) = split '-', $value;
									$mx = -1 if (!defined $mx or $mx eq '');
									$seen_attrs{$key} = $mx;
								}
							}
						</%perl>
						<option value="<% $l->[0]->GetId %>|<% $l->[0]->GetAttributes() %>|<% $l->[0]->GetDescription() %>" <% $l->[0]->GetId eq $linktypeid ? 'selected=""' : '' %>
%							my $text = $rev ? $l->[0]->GetReverseLinkPhrase : $l->[0]->GetLinkPhrase;
%							$text =~ s/\{(\w+:)/{/;
							><% ("&nbsp;&nbsp;" x $l->[1]) |n %><% $text %></option>
%						}
					</select></td>

% if ($rev) {
				<td id="arlinkswap-link1-td"><% ucfirst($links[0]{type}) %> <a href="/show<% $links[0]{type} %>.html?<% $links[0]{type} %>id=<% $links[0]{id} %>"><b><% $links[0]{name} %></b></a></td>
% } else {
				<td id="arlinkswap-link1-td"><% ucfirst($links[1]{type}) %> <a href="/show<% $links[1]{type} %>.html?<% $links[1]{type} %>id=<% $links[1]{id} %>"><b><% $links[1]{name} %></b></a></td>
% }
			</tr>
% if ($links[0]{type} eq $links[1]{type}) {
			<tr>
				 <td colspan="3"><table align="center"><tr><td>
					<div id="swap-clientside" style="display: none">
						<input type="button" class="button" onclick="SwapARLinks(this)" name="swapJS" value="Swap left <% $links[0]{type} %> &lt;=&gt; right <% $links[0]{type} %>">
					</div>
					<div id="swap-serverside" style="display: block">
						<input type="submit" class="button" name="swap" value="Swap left <% $links[0]{type} %> &lt;=&gt; right <% $links[0]{type} %>">
					</div>
					<script type="text/javascript" language="javascript" src="/scripts/ar-linkswap.js"></script>
				</td></tr></table></td>
			</tr>
% }
		</table>

		<table>
			<tr>
				<td valign="top" width="150"><label>Description:</label></td>
				<td>
					<span id="link_desc" class="linkdesc">&nbsp;</span></td>
			</tr>
		</table>

		<div id="attributes">
			<div class="padtop"></div>
			<table>
				<tr>
					<td valign="top" width="150">
					 	<label>Attributes:</label></td>
					<td>
						<%perl>
						foreach my $sec (keys %seen_attrs) 
						{
							my $desc;
							my $isSimple;
							my $tree;
							foreach my $child (@children) 
							{
								if ($child->GetName eq $sec) 
								{
									$desc = $child->GetDescription; 
									$isSimple = !$child->HasChildren;
									$tree = $child;
								}
							}
							$m->out(qq|<div id="$sec" class="ar-attribute">|);
							for(my $index = 0;; $index++)
							{
								last if ($index > 0 && !exists $ARGS{"attr_". $sec . "_$index"});
								if ($isSimple)
								{
									$m->out(qq|<input type="checkbox" name="attr_|. $sec . qq|_$index" value="| . $tree->GetId . "\"");
									$m->out(qq| checked=""|) if ($ARGS{"attr_$sec"."_$index"});
									$m->out(qq|> <i>$sec</i>|);
								}
								else
								{
									$m->out(qq|<select name="attr_|.$sec."_$index\">");
									$m->out(qq|<option value="">[select $sec]</option>|);
									my @q = map { [$_,0] } $tree->Children;
									while (my $l = shift @q)
									{
										unshift @q, map { [$_,$l->[1]+1] } $l->[0]->Children;
										next if ($l->[0]->GetName eq 'ROOT');
										$m->out("<option value=\"".$l->[0]->GetId.'" ');
										$m->out($l->[0]->GetId eq $ARGS{"attr_".$sec."_$index"} ? 'selected=""' : '');
										$m->out(">" . ("&nbsp;&nbsp;" x $l->[1]) . $l->[0]->GetName . "</option>\n");
									}
									$m->out("</select>\n");
								}
								$m->out(qq|<a href="javascript: addAttribute('$sec')">Add another $sec</a>|) if ($seen_attrs{$sec} < 0 || $seen_attrs{$sec} > 1);
							}
							$m->out("</div>");
							$m->out(qq|<div id="$sec-desc" class="ar-attribute-description">$desc</div>|);
						}
						</%perl>
						<noscript>
							NOTE: You do not have JavaScript enabled. Not all of the attributes shown above apply
							to all relationship types and without JavaScript we cannot selectively display
							the appropriate attributes. We recommend that you turn on JavaScript in your browser.
						</noscript>
					</td>
				</tr>
			</table>
		</div>

		<div class="padtop"></div>
		<table>
			<tr>
				<td width="150"><label for="addrel_begindate">Begin date:</label></td>
				<td>
					<& /comp/dateinput, name_prefix => 'begindate', value=> [$begindate_y, $begindate_m, $begindate_d],
						id => "addrel_begindate" &>
					Year-Month-Day</td>
			</tr>
			<tr>
				<td><label for="addrel_enddate">End date:</label></td>
				<td>
					<& /comp/dateinput, name_prefix => 'enddate', value=>[$enddate_y, $enddate_m, $enddate_d],
						id => "addrel_enddate" &>
					Year-Month-Day</td>
			</tr>
			<tr>
				<td></td>
				<td>
					<div class="ar-attribute-description">
					If the link type you selected indicates a temporal link (e.g. <i>was a member of</i>), then enter
					the begin and/or end dates below. These dates are optional, and leaving the end date blank
					indicates that this relationship is still active today:</div></td>
			</tr>
		</table>

		<div class="padlefttop">
			<& /comp/notetext, text => $notetext &>
		</div>
		<div class="padlefttop">
			<input type="hidden" name="link0" value="<% sprintf("%s=%d", $links[0]->{type}, $links[0]->{id}) %>"> 
			<input type="hidden" name="link1" value="<% sprintf("%s=%d", $links[1]->{type}, $links[1]->{id}) %>"> 
			<input type="submit" class="button" value="Submit">
			<input type="hidden" name="submit" value="1">
		</div>
	</fieldset>
</form>

<script type="text/javascript">
<!--
	var wasFormSubmitted = <% $submit %>;
	<%perl>
		print "var attributeDivs = new Array(";
		foreach my $sec (keys %seen_attrs) {
			print "'".$sec."',";
		}
		print "null);\n";
	</%perl>
-->
</script>
<script type="text/javascript" src="link-selecttype.js"></script>

<& /comp/footer &>

%# vi: set ts=4 sw=4 ft=mason :
<%args>
	$id => undef
	$type => ""
	$linktypeid => undef

	$begindate_y => ""
	$begindate_m => ""
	$begindate_d => ""
	$enddate_y => ""
	$enddate_m => ""
	$enddate_d => ""

	$submitvalue => ""
	$swapval => 0
	$notetext => undef
</%args>
<%perl>

	# only logged in users may see this page
	$m->comp("/comp/checkloggedin", 1, 1)
		or return;

	# check volatile preferences (like autoeditor flag)
	$m->comp("/comp/user/check-volatile-preferences", %ARGS);

	# Instantiate MusicBrainz object
	my $mb = $m->comp("/comp/dblogin");

	if ($type eq "" or !MusicBrainz::IsNonNegInteger($id))
	{
		$m->comp("/comp/layout/badarguments", text => "The id, type parameters must be provided to this page.");
		return undef;
	}

	my @types = sort split '-', $type;
	my $link = MusicBrainz::Server::Link->new($mb->{DBH}, \@types);
	if (!$link)
	{
		$m->comp("/comp/layout/badarguments", text => "The type argument is invalid.");
		return undef;
	}

	# check the relationship type
	my $node = $link->newFromId($id);
	if (!$node)
	{
		$m->comp("/comp/layout/badarguments", text => "The relationship you selected no longer exists.");
		return undef;
	}

	# Load the relationship type and entities
	my $oldLinkType = $node->LinkType();
	my @entities = $node->Entities();
	my @links;

	# Load the top level relationship attributes
	my $attrType = MusicBrainz::Server::LinkAttr->new($mb->{DBH});

	# Create the links array that contains all the relevant info for the link entities
	push @links, { type => $types[0], id => $entities[0]->GetId(), obj=>$entities[0], name => $entities[0]->GetName() };
	push @links, { type => $types[1], id => $entities[1]->GetId(), obj=>$entities[1], name => $entities[1]->GetName() };

	# Sort the links in the right order
	if ($links[0]->{type} ne $links[1]->{type})
	{
		@links = sort { $a->{type} cmp $b->{type} }  @links;
	}
	my @oldlinks = @links;


	# swapval indicates if the current entities should be reversed
	# (because the user hit the reverse button)
	if ($submitvalue =~ m/Change direction/i)
	{
		$swapval = !$swapval;
	}
	if ($swapval)
	{
		my $temp = $links[0];
		$links[0] = $links[1];
		$links[1] = $temp;
	}

	# trim dates
	($begindate_y, $begindate_m, $begindate_d, $enddate_y, $enddate_m, $enddate_d) = map { s/\s*(.*?)\s*/$1/; $_ }
	($begindate_y, $begindate_m, $begindate_d, $enddate_y, $enddate_m, $enddate_d);

	# These contain the list of attributes
	my @old_attr_list;

	my $attr = MusicBrainz::Server::Attribute->new($mb->{DBH}, \@types);
	$attr = $attr->newFromLinkId($node->GetId);
	if ($attr)
	{
		@old_attr_list = @{$attr->GetAttributes()};
	}

	# attributes contains the available attributes for the current relationship type.
	# (.e.g. additional=0-1)
	my ($desc, $attributes);
	if ($linktypeid)
	{
		($linktypeid, $attributes, $desc) = split '\|', $linktypeid;
	}
	else
	{
		$linktypeid = $node->GetLinkType();
		$desc = $oldLinkType->GetDescription();
		$attributes = $oldLinkType->GetAttributes();
		foreach my $ref (@old_attr_list)
		{
			for(my $index = 0;; $index++)
			{
				next if exists $ARGS{"attr_" .$ref->{name} . "_$index"};
				$ARGS{"attr_" . $ref->{name} . "_$index"} = $ref->{value};
				last;
			}
		}
	}

	# prepare validation
	my (@errors, @new_attr_list);
	$ARGS{"v::attrType"} = $attrType;
	$ARGS{"v::attributes"} = $attributes;
	%ARGS = $m->comp("/comp/relationship/checkattributes", %ARGS);
	@new_attr_list = @{ $ARGS{"v::new_attr_list"} };
	@errors = @{ $ARGS{"v::errors"} };

	if ($submitvalue ne "")
	{
		# prepare forward url after action.
		my $type = ($links[0]{type} == "album" ? "release" : $links[0]{type});
		my $url = "/show/".$type."/?".$type."id=".$links[0]{id});

		# handle click of Cancel button
		if ($submitvalue =~ m/cancel/i)
		{
			return $m->comp("/comp/redirect", $url);
		}
		if ($submitvalue =~ m/Enter Moderation/i)
		{
			# validate
			push @errors, "Please select a relationship type"
				if ($linktypeid !~ /^\d+$/);
			push @errors, "Please enter an valid start date"
				if (!MusicBrainz::IsValidDateOrEmpty($begindate_y, $begindate_m, $begindate_d));
			push @errors, "Please enter an valid end date"
				if (!MusicBrainz::IsValidDateOrEmpty($enddate_y, $enddate_m, $enddate_d));
			push @errors, "The end date needs to be later then the begin date"
				if (!MusicBrainz::IsDateEarlierThan($begindate_y, $begindate_m, $begindate_d, $enddate_y, $enddate_m, $enddate_d));
			push @errors, "Please select a subtype of the currently selected relationship type"
				if (!$desc && $linktypeid);

			if (@errors == 0)
			{
				my $newLinkType = $oldLinkType->newFromId($linktypeid);
				if ($newLinkType)
				{
					$m->comp(
						"/comp/entermods",
						DBH => $mb->{DBH},
						sub => sub {
							my @mods = Moderation->InsertModeration(
								DBH            => $mb->{DBH},
								uid            => $session{uid},
								privs          => $session{privs},
								type           => &ModDefs::MOD_EDIT_LINK,
								# --
								newentities    => \@links,
								oldentities    => \@oldlinks,
								newlinktype    => $newLinkType,
								oldlinktype    => $oldLinkType,
								node           => $node,
								begindate      => [ $begindate_y, $begindate_m, $begindate_d ],
								enddate        => [ $enddate_y, $enddate_m, $enddate_d ],
								newattributes  => \@new_attr_list,
								oldattributes  => \@old_attr_list,
							);

							$mods[0]->InsertNote($session{'uid'}, $notetext)
								if $mods[0]
								and $notetext =~ /\S/;
						},
						success_url => $url,
					) or return;
				}
			}

		}
	}
	else
	{
		# prepare dates from relationship
		($begindate_y, $begindate_m, $begindate_d) = $node->GetBeginDateYMD();
		($enddate_y, $enddate_m, $enddate_d) = $node->GetEndDateYMD();
	}

	# form configuration and parameters.
	$ARGS{"v::formurl"} = "/edit/relationship/edit.html";

	$ARGS{"v::errors"} = \@errors;
	$ARGS{"v::links"} = \@links;
	$ARGS{"v::begindate"} = [ $begindate_y, $begindate_m, $begindate_d ];
	$ARGS{"v::enddate"} = [ $enddate_y, $enddate_m, $enddate_d ];

	# store root of the relationship tree
	$ARGS{"v::root"} = $oldLinkType->Root;

	# store arguments which might have been modified into args hash again
	$ARGS{"swapval"} = $swapval;
	$ARGS{"linktypeid"} = $linktypeid;

	$m->comp("/comp/relationship/form", %ARGS);

</%perl>

%# vi: set ts=4 sw=4 ft=mason :
<%args>
$catid => ""
</%args>
<%perl>

my ($cat, $id) = $catid =~ /
	^\s*				# start of line, leading space
	(\w*)				# category (e.g. misc)
	(?:					# either:
		\s*\/\s*		#  a slash (optional whitespace)
		|				# or:
		\s+				#  mandatory whitespace
	)
	([0-9A-Fa-f]{8})	# FreeDB ID (e.g. 12345678)
	\s*$				# trailing space, end of line
	/x;

return $m->comp("id-error", catid => $catid)
	if not defined $cat;

my $mb = $m->comp("/comp/dblogin");

my $fdb = FreeDB->new($mb->{DBH});
my $lookup = $fdb->LookupByFreeDBId($id, $cat);

return $m->comp("not-found", catid => $catid)
	if not defined $lookup;

# Right, I'm making a decision here to use %session to store all this stuff,
# instead of passing it all around in POSTed data.  The upside of this is that
# it makes the coding much simpler, and the HTTP transactions less convoluted;
# plus you don't have to re-validate all the data on every request.
# The downside is that going "back" in the browser history won't unwind your
# work as you might expect.  Also you'll need a session per import if you want
# to do multiple FreeDB imports in parallel.

# Clear out any existing freedb data
$m->comp("cancel.html", "true");

# Save the original FreeDB lookup results
$session{"freedb_lookup"} = $lookup;
my $t = $session{"freedb_tracks"} = @{ $lookup->{tracks} };

# $lookup has keys:
# - freedbid (eq $id)
# - freedbcat (eq $cat)
# - artist (string)
# - sortname (??? is this meant to be in there?)
# - album (string)
# - tracks: array ref, each entry is hash of {tracknum, track}
# - durations: space-joined list of integers, one per track

# Let's start off with some trivial data tidying
my $tidy = sub {
	local $_ = shift;
	use Encode qw( encode decode );
	$_ = decode "utf-8", $_;
	s/\A\s+//;
	s/\s+\z//;
	s/\s+/ /g; #/#
	tr/\x{0060}\x{00B4}"\x{00AB}\x{00BB}/'/; #"#
	encode "utf-8", $_;
};

$session{"freedb_artist"} = &$tidy($lookup->{"artist"});
$session{"freedb_album"} = &$tidy($lookup->{"album"});

for my $i (0 .. $t-1)
{
	# Hmmm, does freedb always return 1..n tracks (no gaps?)
	# i.e. do we ignore "tracknum" ?

	my $n = &$tidy($lookup->{"tracks"}[$i]{"track"});

	# Remove leading track number
	my $n1 = $i+1;
	my $n2 = sprintf "%02d", $n1;
	$n =~ s/^($n1|$n2)\b[\.\)]?\s*//;

	$session{"freedb_track$i"} = $n;
}

# TODO "Guess Case" on everything?

# Save these as the defaults.

for ("artist", "album", map { "track$_" } 0..$t-1)
{
	$session{"freedb_default_$_"} = $session{"freedb_$_"};
}

# Hence we have three sets of values:
# - $session{"freedb_lookup"} contains the data originally fetched from FreeDB
# - $session{"freedb_default_X"} is the same thing after some simple tidying up
# - $session{"freedb_X"} is our current 'working copy'

$session{"freedb_ready"} = 1;

# First question: to VA or not to VA?
return $m->comp("/comp/redirect", "/freedb/select-macsac.html");

</%perl>

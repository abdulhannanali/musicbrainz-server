%# vi: set ts=4 sw=4 ft=mason :
<%args>
$artistid
</%args>
<%def .GetRelatedModeration>
<%perl>
    my ($modobj, $artistid, $uid) = @_;
	my $result;

	my $try_search = sub {
		my ($query, $voter_id) = $m->comp("/mod/search/setquery.inc", @_);
		my ($status, $list, $num) = $modobj->GetModerationList($query, $voter_id, 0, 1);

		return $list->[0]
			if $status == Moderation::SEARCHRESULT_SUCCESS
			and $num > 0;

		return "timeout"
			if $status == Moderation::SEARCHRESULT_TIMEOUT;

		();
	};

    # First, look for moderations that are open by the given artist
	$result = &$try_search(
        artist_type     => 3, # only this artist ...
        artist_id       => $artistid,
        moderator_type  => 5,
        voter_id        => $uid,
        vote_cast       => [ &ModDefs::VOTE_NOTVOTED ],
        mod_status      => [ &ModDefs::STATUS_OPEN ],
        orderby         => "desc"
	) and return ($result, "Please vote on this moderation by the same artist:")
		unless $artistid == &ModDefs::VARTIST_ID;

    # Now look for moderations from subscribed artists
	$result = &$try_search(
        mod_status      => [ &ModDefs::STATUS_OPEN ],
        vote_cast       => [ &ModDefs::VOTE_NOTVOTED ],
        voter_type      => 0,
        moderator_type  => 5,
        artist_type     => 4, # subbed artists
        orderby         => "asc"
	) and return ($result, "Please vote on this moderation by one of your subscribed artists:");

    # Now look for moderations from related artists
	$result = &$try_search(
        artist_type     => 5, # only this artist ...
        artist_id       => $artistid,
        moderator_type  => 5,
        voter_id        => $uid,
        vote_cast       => [ &ModDefs::VOTE_NOTVOTED ],
        mod_status      => [ &ModDefs::STATUS_OPEN ],
        orderby         => "desc"
	) and return ($result, "Please vote on this moderation by a related artist:");

    # Now look for any open moderation
	$result = &$try_search(
        moderator_type  => 5,
        voter_id        => $uid,
        vote_cast       => [ &ModDefs::VOTE_NOTVOTED ],
        mod_status      => [ &ModDefs::STATUS_OPEN ],
        orderby         => "desc"
	) and return ($result, "Please vote on this random moderation:");

	return;
</%perl>
</%def>
<%perl>

my $mb = $m->comp("/comp/dblogin");
my $mod = Moderation->new($mb->{DBH});

my ($relmod, $pleasevote) = $m->comp(".GetRelatedModeration", $mod, $artistid, $session{uid});

$m->comp(
	"/comp/header_inline",
	title => 'Inline Moderation',
	head => '<base target="_parent">',
); 

if ($relmod eq "timeout")
{
    </%perl>
	<p>(Related moderation search timed out - sorry)</p>
    <%perl>

    $m->comp("/comp/footer_inline"); 
    return;
}

if (not $relmod)
{
    </%perl>
	<p>No open moderations found.</p>
    <%perl>

    $m->comp("/comp/footer_inline"); 
    return;
}

my @notes = do {
	my $notes = MusicBrainz::Server::ModerationNote->new($mb->{DBH});
	$notes->newFromModerationIds($relmod->GetId);
};

</%perl>

<p style="margin-top: 0"><% $pleasevote %></p>

<form method="POST" action="/bare/vote.html"
      enctype="application/x-www-form-urlencoded" 
      class="formstyle" target="_self">

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0"
       BGCOLOR="#000000" WIDTH="100%">
<TR><TD width="100%">
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="1" CELLPADDING="3">

<%perl>
my $show_button = 1;
$m->comp(
	"/comp/showmod",
	mod		=> $relmod,
	notes	=> \@notes,
	voter	=> $session{uid},
	voteflag=> \$show_button,
    inline  => 1,
);
</%perl>

</table>
</td></tr>
</table>

<INPUT TYPE="hidden" NAME="url" 
       VALUE="<% $r->uri() . "?" . $r->args() %>">

</form>

<& /comp/footer_inline &>
